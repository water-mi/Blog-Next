<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>欢迎</title>
    <url>/2018/07/26/Welcome/</url>
    <content><![CDATA[<p>欢迎来到本博客</p>
<span id="more"></span>
<p><strong>博客目前正在建设</strong></p>
]]></content>
  </entry>
  <entry>
    <title>做题日志 V1.0</title>
    <url>/2020/01/18/75/</url>
    <content><![CDATA[<p>随时停更，请勿催更<br><span id="more"></span></p>
<h2 id="1-Bzoj1176-Mokia"><a href="#1-Bzoj1176-Mokia" class="headerlink" title="1 - Bzoj1176 Mokia"></a>1 - Bzoj1176 Mokia</h2><p>把询问操作差分，然后就变成了三维偏序问题。</p>
<p>Tag: 差分，cdq 分治</p>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>[随便写写]总结</tag>
      </tags>
  </entry>
  <entry>
    <title>线性基习题集</title>
    <url>/2019/07/13/74/</url>
    <content><![CDATA[<p>一些线性基的练习题，线性基数组用$d[]$表示</p>
<span id="more"></span>
<h3 id="T1-LuoguP3857"><a href="#T1-LuoguP3857" class="headerlink" title="T1-LuoguP3857"></a>T1-LuoguP3857</h3><p>　　考虑线性基的一个性质：如果线性基的前$n$位都有值，则$[1,2^n-1]$一定能够被表出。</p>
<p>　　所以这启发我们，如果将所有的开关转化成二进制插入到线性基中，则设有值的有$k$位，则答案一定是$2^k$。</p>
<h3 id="T2-LuoguP4570"><a href="#T2-LuoguP4570" class="headerlink" title="T2-LuoguP4570"></a>T2-LuoguP4570</h3><p>　　考虑按照权值从大到小将$\text{id}$插入到线性基中，为什么贪心是对的，限于篇幅，给一篇<a href="https://blog.csdn.net/lqybzx/article/details/79416710">博客</a>。</p>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]线性代数-线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>7.12专题分享总结</title>
    <url>/2019/07/12/73/</url>
    <content><![CDATA[<p>7.12所讲的题目的落实，涉及图论、计数和思维题。</p>
<span id="more"></span>
<h3 id="T1-LuoguP4609"><a href="#T1-LuoguP4609" class="headerlink" title="T1-LuoguP4609"></a>T1-LuoguP4609</h3><p>　　第一类斯特林数＋组合数</p>
<p>　　题解见<a href="https://blog.water-mi.com/2019/01/17/41/">之前的博客</a></p>
<h3 id="间章-关于第二类斯特林数某一公式的证明"><a href="#间章-关于第二类斯特林数某一公式的证明" class="headerlink" title="间章-关于第二类斯特林数某一公式的证明"></a>间章-关于第二类斯特林数某一公式的证明</h3><script type="math/tex; mode=display">
{\Large n^m}={\Large\sum\limits_{k=0}^m}
\begin{pmatrix}
n \\ k
\end{pmatrix}
\begin{Bmatrix}
m \\ k
\end{Bmatrix}
{\large k!}</script><p>证明：</p>
<p>　　将$m$个本质不同的小球放入$n$个本质不同的盒子（可空）中，显然是$n^m$。</p>
<p>　　另一种思路表示先枚举$k$个盒子非空，乘上$\begin{pmatrix} n\k\end{pmatrix}$表示从$n$个盒子中选出$k$个盒子，将这些球放进这$k$个盒子的代价是${\begin{Bmatrix}m\k\end{Bmatrix}}\times k!$，乘上阶乘是因为盒子本质不同。</p>
<blockquote>
<p>和 $n$ 有关的只有 $C_n^k$，而这东西是可以利用杨辉三角快速转移的。常见于$\text{DP}$题以及多项式题。</p>
</blockquote>
<h3 id="T2-Bzoj4710"><a href="#T2-Bzoj4710" class="headerlink" title="T2-Bzoj4710"></a>T2-Bzoj4710</h3><p>　　容斥原理＋组合数</p>
<p>　　题解见<a href="https://blog.water-mi.com/2019/01/28/62/">之前的博客</a></p>
<h3 id="T3-CodeForces-961G"><a href="#T3-CodeForces-961G" class="headerlink" title="T3-CodeForces 961G"></a>T3-CodeForces 961G</h3><p>　　不难发现$Ans=p\sum val_i$（因为每个元素本身的权重是相同的），其中$p$是一个待定的系数。</p>
<p>　　有一种斯特林反演的方法，但是式子推起来很麻烦。</p>
<p>　　另一种思路是考虑划分集合后，因为$W(S)=|S|\cdot\sum_{i\in S}val_i$，故对于元素$i\in S$可以当做$S$中的每个元素都对$i$产生了一次贡献，所以我们只要枚举每一个数对$i$的贡献即可。</p>
<p>　　$i$对自己的贡献显然是$\begin{Bmatrix}n\k\end{Bmatrix}$，剩下的$n-1$个数的贡献则是$(n-1)\times\begin{Bmatrix}n-1\k\end{Bmatrix}$。</p>
<p>　　其中$\begin{Bmatrix}n-1\k\end{Bmatrix}$表示枚举的那个数和$i$在同一集合的方案数。</p>
<p>　　所以系数$p=\begin{Bmatrix}n\k\end{Bmatrix}+(n-1)\times\begin{Bmatrix}n-1\k\end{Bmatrix}$</p>
<h3 id="T4-CodeChef-CNTDSETS"><a href="#T4-CodeChef-CNTDSETS" class="headerlink" title="T4-CodeChef CNTDSETS"></a>T4-CodeChef CNTDSETS</h3><p>　　将平移的限制转化为每一维都存在该维坐标为$0$的点，距离的限制转化为至少有一维的最大坐标为$d$。</p>
<p>考虑计算最大值小于等于$x$的方案$f(x)$，容斥“每一维都存在$0$”。答案就是：</p>
<script type="math/tex; mode=display">
f(d)-f(d-1),f(d)=\sum_{i=0}^n(-1)^i\times 
\begin{pmatrix}
n\\i
\end{pmatrix}
\times2^{d^i(d+1)^{n-i}}</script><h3 id="T5-CodeForces-892E"><a href="#T5-CodeForces-892E" class="headerlink" title="T5-CodeForces 892E"></a>T5-CodeForces 892E</h3><p>　　考虑最小生成树$\text{Kruskal}$的一个性质，即不同权值的边是互不影响的。对于每一次询问，我们只需考虑同种权值的边能否出现在一棵生成树上。</p>
<p>　　预处理处每一种权值在处理之前该边对应的两点所在的联通块，然后对于每一次询问，先还原询问的每条边的连接状态，再去按照$\text{Kruskal}$连接所对应的的联通块，如果不会连接到相同的联通块，则是可行的。</p>
<h3 id="T6-Bzoj4886"><a href="#T6-Bzoj4886" class="headerlink" title="T6-Bzoj4886"></a>T6-Bzoj4886</h3><p>　　其实并不用考虑严格递增的问题，我们只需要使得底不重复出现就行了。</p>
<p>　　考虑一种建图方式，对于一个长方形$(a,b)$，建立一条$a$与$b$的无向边，考虑给边定向，则入点表示选其作为一个底，出点表示作为一条高，由于题目限制，每个点的入度必须为$1$，所以贡献为$(\text{degree}-1)\times \text{val}$。</p>
<p>​    　因为只有$n$个点$n$条边，所以一个联通块的形态要么是树要么是基环树，然而树的根节点贡献是$\text{degree}\times \text{val}$，所以我们对于树要使权值最大的点为根（你可以认为其入度为$1$，但并不减少贡献）。</p>
<h3 id="T7-LuoguP4366"><a href="#T7-LuoguP4366" class="headerlink" title="T7-LuoguP4366"></a>T7-LuoguP4366</h3><p>　　主要解决边数很多的问题，剩下的细节就只有原图单向边和不要用优先队列就好了。</p>
<p>　　考虑到异或的性质，只需要对于每一个节点$i$，枚举每个二进制位$p$，连边$(i,i\oplus(1&lt;&lt;p),(1&lt;&lt;p)*c)$即可，边数缩减到$O(nlogn+m)$。</p>
<h3 id="T8-LuoguP1407"><a href="#T8-LuoguP1407" class="headerlink" title="T8-LuoguP1407"></a>T8-LuoguP1407</h3><p>　　考虑给边定向，对于婚姻关系，男向女连边，对于曾交往过的关系，女向男连边，如果一对婚姻关系中的两人在同一个强连通分量里面，则这对关系是不稳定的。</p>
<p>　　考虑这样做为什么是对的，一对不稳定的稳定关系必然处在一个环满足这个环上的边按婚姻－交往－婚姻－交往环形排列，所以以上联边方法可以保证将答案最大化。</p>
<h3 id="T9-Atcoder2134"><a href="#T9-Atcoder2134" class="headerlink" title="T9-Atcoder2134"></a>T9-Atcoder2134</h3><p>　　按照原题连边的话边会达到$O(nq)$，所以我们考虑如何缩小边的规模，考虑一次批量加边对$\text{MST}$的贡献，假设我们已经把边$(x,y,z)$按照$\text{Kruskal}$的方式处理完毕，则表示$(x,y)$两点在同一联通块内，所以我们不妨考虑将边$(y,x+1,z+1)$等效变为$(x,x+1,z+1)$，对于原图中的一次批量加边操作，设$d[i]$表示$(i,i+1)$的最小边权，每次仅需更新$d[x],d[y]$。（注意边$(x,y,z)$是无法等效的，直接加进即可）。</p>
<p>　　最后两次环形更新$d[i]=min(d[i],d[i-1]+2)$，更新两次是因为第一次中的最末尾的$d$可能更新最头的$d$。</p>
<p>　　然后将$(i,i+1,d[i])$加入图中，求出$\text{MST}$。</p>
<h3 id="T10-Bzoj1922"><a href="#T10-Bzoj1922" class="headerlink" title="T10-Bzoj1922"></a>T10-Bzoj1922</h3><p>　　一边跑$\text{Dijkstra}$，一边跑拓扑排序即可，只有一个点的保护点都出堆，该点才能入堆。</p>
<h3 id="T11-Uoj67"><a href="#T11-Uoj67" class="headerlink" title="T11-Uoj67"></a>T11-Uoj67</h3><p>　　删去一个点后只剩$n-1$个点，树有$n-2$条边，所以原图中有$m-(n-2)$条连边的非割点就是答案。</p>
<h3 id="T12-Bzoj4289"><a href="#T12-Bzoj4289" class="headerlink" title="T12-Bzoj4289"></a>T12-Bzoj4289</h3><p>　　考虑一种网络流式的建图方式—补流，有这样一个东西$max(a,b)=a+max(b-a,0)$。</p>
<p>　　所以对于每一个点，我们经过时可以加上它入边的权值即$a$，然后考虑在点的内部补差值。</p>
<p>　　具体来说，对于每一个点，将其所有的边从小到大排序，从小往大连差价边，从大往小连$0$边，也就是说，实际上原图的$n$个点并不用加入图中，直接将拆出来的两个点$(i,i+m)$间连权值为$w$的边，然后将$i$分配到编号小的点，$i+m$分配给编号大的点，作上述操作。</p>
<p>　　最后考虑怎么求出最短路，对于分配给$1$的出边，新建源点向$i$连边权为其$w$的边，对于分配给$n$的入边，向$i+m$连权值为$0$的边。</p>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[随便写写]总结</tag>
      </tags>
  </entry>
  <entry>
    <title>近期考试的总结</title>
    <url>/2019/06/23/72/</url>
    <content><![CDATA[<blockquote>
<p>此文从6.23日开始更新，更新至7.13</p>
<p>用于发表一些认为有价值的题的简要的题解和考试时的感想</p>
<p>由于写博客对于我来说太浪费时间，于是变成随缘更新了</p>
</blockquote>
<span id="more"></span>
<h2 id="6-23"><a href="#6-23" class="headerlink" title="6.23"></a>6.23</h2><p>　　今天垫底了（不$\text{Fake}$），主要是第一题即使一眼$0/1$分数规划，但是纠结在了怎么计算方案而忽略了本题最重要的性质。将大部分的时间都浪费在了写第一题，以为是一个很高深的题目。</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>　　本场考试最容易的题，显然可以想到$0/1$分数规划，$\text{check}$的话可以直接扫描一遍找出是否存在某一个值满足$t[i]-k\times s[i]\le 0$（$t[i]$为时间，$s[i]$为安全程度，$k$为比值）。</p>
<p>　　在这个基础上仔细思考一下不难发现答案就是$min(\frac{t[i]}{s[i]})$（证明见附录），所以只要找出有多少个相同的$min(\frac{t[i]}{s[i]})$（设有$tot$个）则方案数就是$2^{tot}-1$（模数差评）。</p>
<h2 id="6-24"><a href="#6-24" class="headerlink" title="6.24"></a>6.24</h2><h3 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a>T1</h3><p>　　依然是本场考试最愚蠢的题，考虑第$i$种物体取$x$件和取$x+1$件会产生的新的价值，计算可得新的价值为：$a_i-(2x+1)b_i$，注意到新的价值只与当前去的件数有关，所以可以拿这个当做新取物品的权值（记一个$cnt[i]$表示第$i$种物品取的件数），开一个堆即可，时间复杂度$O(m\log_2n)$。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>　　正着思考显然不会很好，考虑倒着思考，发现一个元素$0$只能和另一个元素合并或者不动，同时不难发现两个一个正数和其他数合并不会比他们分别减到$0$再合并要更优，于是统计一下每一种数的个数然后根据上述结论模拟一下即可，复杂度大概是$O(n\log_2n+n)$的。</p>
<p>　　这道题考场上以为是数列，然后写了很久，最后$10$分钟发现是集合（更加容易了），随便写了一下就交上去了，事实上只有一个细节没有处理好（数据过弱导致自己甚至还有$30pts$）。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>　　我也不知道为什么考场上没有想到正解。</p>
<p>　　从每一个点开始向四周连边，边权为这两个点之间的较大点权，考虑一个点最多能放多少水，显然是它到外界的所有路径的边权最大值的最小值，所以考虑将外界看作一个点，由这个点开始求出整张图的最小生成树，最后求出每一个点到该点路径上边权的最大值，$\text{dfs}$即可。</p>
<h2 id="6-25"><a href="#6-25" class="headerlink" title="6.25"></a>6.25</h2><h3 id="T1-2"><a href="#T1-2" class="headerlink" title="T1"></a>T1</h3><p>　　一道思维好题。</p>
<p>　　考虑一个什么样的数能作为一个区间的中位数，当且仅当这个区间内小于它的数的个数减去大于它的数的个数大于等于$0$且小于等于$1$才可以。</p>
<p>　　利用这个性质我们可以采取二分答案求出中位数的中位数的方式，假设当前二分的中位数为$mid$，在原数列的一段区间中，如果小于等于它的数（记为$x$），与大于它的数（记为$y$）满足$x-y\ge 0$，则说明这个区间的中位数$\le mid$。</p>
<p>　　令数列中小于等于它的数为$-1$，大于的数为$1$，找出所有的满足区间和$\le 0$的区间，可以记一个前缀和$s<em>i,i\in[0,n],s_0=0$，则一个满足条件的区间$[l,r]$可以表示为：$s_r-s</em>{l-1}\le 0$即$s_{l-1}\ge s_r$，利用树状数组可以方便地求出满足条件的区间个数。</p>
<p>　　至于求出上面这些区间的个数可以用来干什么，如果个数大于$\frac {n(n+1)}{4}$，则说明二分的中位数过大，需要缩小，当$l&gt;r$时，$l$就是中位数。</p>
<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>　　我承认这题我思维僵化了。</p>
<p>　　考虑二分答案，贪心的选取每一次考试的最后时间，然后将考试的出现时间从小到大排序，记个剩余时间依次模拟即可。</p>
<p>　　实际上是本场考试最容易的题。</p>
<h3 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h3><p>　　贪心地考虑这个问题，我们肯定是要最大化放置一个关键点可以控制到的叶子数，假设当前的$k$值为$2$，存在某一个节点$t$有这样的两个叶子：一个叶子到该节点的距离为$2$，另一个叶子到它的距离为$1$，我们若要使放置下来的节点既要控制这两个叶子，也要最大化控制其他叶子节点的概率，所以我们选择在节点$t$放置。</p>
<p>　　上述讨论启发我们将所有未被控制的的叶子按照深度从大到小排序，从头到尾处理每一个叶子，每处理到一个未被控制的叶子，将其$k$级祖先标记，然后更新控制情况，时间复杂度为$O(Tn^2)$</p>
<h2 id="6-26"><a href="#6-26" class="headerlink" title="6.26"></a>6.26</h2><h3 id="T1-3"><a href="#T1-3" class="headerlink" title="T1"></a>T1</h3><p>　　乍一看很难，实际上不难发现倒着处理操作会变得很容易，因为当我们倒序遍历到某一个操作时，之前的操作是无法影响它的执行次数的。</p>
<p>　　所以开两个树状数组，一个维护整个数组的区间和，一个维护操作次数，倒序遍历到某一个操作，如果是操作$1$就将第一个$\text{BIT}$中的指定区间加上自身的执行次数（在第二个$\text{BIT}$中查询），操作$2$同理。</p>
<h3 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h3><p>　　好题，不难得出结论$c=\prod\limits_{i=1}^n(a_i-i+1)$</p>
<p>　　所以一个$a_i$的贡献就是$a_i-i+1$，设其为$b_i$，显然$b_i$与$a_i$一一对应，所以我们只需要最大化$b_n$，而$b$数组又是$c$的约数，所以可以枚举约数，同时，我们贪心地认为其他的$b_i$要尽可能大。</p>
<p>　　额外要说的是：$\because a<em>i\le a</em>{i+1}\therefore b<em>i\le b</em>{i+1}+1$，所以在枚举$b$的时候我们要记得放大范围。</p>
<h3 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h3><p>　　考虑到$k$个古城都是两两右边的，所以我们先不处理这些边，对$m$条边建出的图跑一次最短路，至少有一个古城可以算出最短路，所以我们可以利用已经算出最短路的古城中最短路最小的那个来更新其它的古城。</p>
<p>　　然后我们就排除了这$k$个古城互相之间的影响，最后要做的就是用这$k$个古城来更新整张图的最短路。</p>
<h3 id="T5-1"><a href="#T5-1" class="headerlink" title="T5"></a>T5</h3><p>　　一道很容易的题，差分一下维护区间最大值即可（有方法可以做到$O(n)$，但是没有必要）。</p>
<h2 id="6-29"><a href="#6-29" class="headerlink" title="6.29"></a>6.29</h2><p>　　$\text{Anson}$欢乐赛，看谁小错误更多。</p>
<h3 id="T1-4"><a href="#T1-4" class="headerlink" title="T1"></a>T1</h3><p>　　我就想用树形依赖背包做，左儿子右兄弟可以做到$O(nm)$</p>
<h3 id="T2-2"><a href="#T2-2" class="headerlink" title="T2"></a>T2</h3><p>　　第一次做这种类型的$dp$，之前都有意跳过了，当时觉得没有办法理解。现在看来是一个很简单的树形动规。</p>
<h3 id="T3-2"><a href="#T3-2" class="headerlink" title="T3"></a>T3</h3><p>　　缩完点以后变成$\text{DAG}$，然后就只有一种决策了，拓扑排序模拟即可。</p>
<h3 id="T4-1"><a href="#T4-1" class="headerlink" title="T4"></a>T4</h3><p>　　这题甚至在树剖查询区间写反还有$\text{20pts}$，树剖完以后，第一个子问题写一个$\text{BIT}$，第二个子问题写一个可持久化权值线段树。</p>
<h2 id="7-12"><a href="#7-12" class="headerlink" title="7.12"></a>7.12</h2><p>　　还是$\text{Anson}$快乐赛</p>
<h3 id="T2-3"><a href="#T2-3" class="headerlink" title="T2"></a>T2</h3><p>　　一道很有意思的题，考虑到起点和终点都是加油站，所以不妨最短路处理出所有加油站之间的最短距离，然后离线做。</p>
<p>　　具体就是将询问和边的权值分别从小到大排序，然后按照询问的权值将边权小于等于其的边加入图中，并查集维护连通性。</p>
<p>　　但是边数是$O(n^2)$的，考虑怎么优化，一遍最短路计算出所有节点所能到达的最近的加油站$W$以及到它的距离$dist$，枚举原图每条边的两个端点$(u,v,w)$，建立一条边$(W[u],W[v],dist[u]+dist[v]+w)$（$W$相等就不用加了），边数变为$O(m)$。正确性比较显然，这里不给出证明。</p>
<h2 id="7-13"><a href="#7-13" class="headerlink" title="7.13"></a>7.13</h2><h3 id="T1-5"><a href="#T1-5" class="headerlink" title="T1"></a>T1</h3><p>　　有如下结论（讨论一下可以得出）：</p>
<blockquote>
<p>点$a,b$在以$c$为根的树中的最近公共祖先为在原树中$lca(a,b),lca(a,c),lca(b,c)$中深度最大者。</p>
</blockquote>
<p>　　所以操作$1$我们只需要记下当前的根$rt$即可。</p>
<p>　　对于剩下两个操作，我们只需要讨论查询的点是否在原树中$rt$到根的那条链上，不在则直接子树操作，否则先对于整颗树修改，然后再取消$rt$到查询点的那条链上查询点的儿子的子树的贡献。</p>
<p>　　树剖可以找出我们需要的点，见附录。</p>
<p>　　原题是$\text{CodeForces 916E}$。</p>
<h3 id="T3-3"><a href="#T3-3" class="headerlink" title="T3"></a>T3</h3><p>　　倒着思考，设$f[u]$表示点$u$的答案，其取值为$f[v]+dis(u,v)$中的次小值（其中$v$表示$u$的一个出点）。</p>
<p>　　由于已知终点的$f$，所以可以倒序求出所有点的$f$。</p>
<p>　　原题是$\text{Bzoj 2622}$。</p>
<h2 id="8-31"><a href="#8-31" class="headerlink" title="8.31"></a>8.31</h2><blockquote>
<p>在本段集训的最后一天更一次博</p>
</blockquote>
<h3 id="T1-6"><a href="#T1-6" class="headerlink" title="T1"></a>T1</h3><p>　　就说一下 $\text{95pts}$ 的做法</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="6-23-T1证明"><a href="#6-23-T1证明" class="headerlink" title="6.23 T1证明"></a>6.23 T1证明</h3><blockquote>
<p>设有两个分数$\frac ab=t_1$、$\frac cd=t_2$，其中$t1&lt;t2$，$a,b,c,d&lt;0$</p>
<p>则有：</p>
<script type="math/tex; mode=display">
\frac{a+b}{c+d}=\frac{t_1c+t_2d}{c+d}=\frac{t_1(c+d)+(t_2-t1)d}{c+d}=t_1+\frac{(t_2-t_1)d}{c+d}</script><p>$\because\frac{(t_2-t_1)d}{c+d}&gt;0\therefore\frac{a+b}{c+d}&gt;\frac ac$</p>
</blockquote>
<h3 id="7-13-关于树剖找出某两个点到其公共祖先下的两个对应点"><a href="#7-13-关于树剖找出某两个点到其公共祖先下的两个对应点" class="headerlink" title="7.13 关于树剖找出某两个点到其公共祖先下的两个对应点"></a>7.13 关于树剖找出某两个点到其公共祖先下的两个对应点</h3><p>　　先找出$lca$，然后分开跳，如果某一时刻$lca$和当前的点在同一条重链上，则对应点为$lca$的重儿子，否则必有某一时刻$fa[top[]]==lca$，此时$top[]$就是需要找的点。</p>
<pre><code class="lang-cpp">int di(int tp, int x) &#123;//tp为lca，x为需要读入的点
    while(top[x] != top[tp]) &#123;
        if(fa[top[x]] == tp) return top[x];
        x = fa[top[x]];
    &#125; return son[tp];//同一条重链
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>[随便写写]总结</tag>
      </tags>
  </entry>
  <entry>
    <title>HNOI2019 游记</title>
    <url>/2019/04/08/71/</url>
    <content><![CDATA[<p>链接：<a href="https://water_mi.coding.me/pdf/HNOI2019%E6%B8%B8%E8%AE%B0.pdf">HNOI2019 游记</a></p>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>[Report]各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title>JXOI2017-2018 解题报告</title>
    <url>/2019/03/28/70/</url>
    <content><![CDATA[<p>链接：<a href="https://water_mi.coding.me/pdf/JXOI.pdf">JXOI2017-2018 解题报告</a></p>
<p>代码预览：<a href="https://github.com/water-mi/My-Code/tree/master/%E5%8E%86%E5%B9%B4%E7%9C%81%E9%80%89/JXOI">Github</a></p>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[Report]各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流20+4题解题报告（已更前20题）</title>
    <url>/2019/03/15/69/</url>
    <content><![CDATA[<p>链接：<a href="https://water_mi.coding.me/pdf/NetFlow.pdf">网络流20+4题解题报告</a></p>
<p>代码预览：<a href="https://github.com/water-mi/My-Code/tree/master/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98">Github</a> </p>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]图论-网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces528A （STLset）</title>
    <url>/2019/02/03/68/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="http://codeforces.com/problemset/problem/528/A">CodeForces</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>横着切和竖着切是互相不影响的。</p>
<p>假设现在横着切成了很多段，显然此时面积最大的矩形的一边长就是这些段中长度最长的一段。竖着切的也是一样的。</p>
<p>所以就可以用$set$来维护切过的横、纵坐标与每一段的长度。</p>
<p>修改时，先找到相邻的两刀，再找到对应的长度，删去这个长度，再加入切出来的两个新的长度。</p>
<p>一开始要把$\mathbf W$、$\mathbf H$这些东西加进去。</p>
<pre><code class="lang-cpp">#include &lt;set&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::sort; using std::swap;
using std::unique; using std::lower_bound;
using std::set;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int _ = 2e5 + 10;
int W, H, n, w[_], h[_];

int main () &#123;
    read(W), read(H), read(n);
    set&lt;int&gt; sw, sh, qw, qh;
    sw.insert(W), sw.insert(-W);
    sh.insert(H), sh.insert(-H);
    qw.insert(0), qw.insert(W), qw.insert(-W);
    qh.insert(0), qh.insert(H), qh.insert(-H);
    ++w[W], ++h[H]; char ch[3]; int x;
    for(int i = 1; i &lt;= n; ++i) &#123;
        scanf(&quot;%s%d&quot;, ch, &amp;x);
        if(ch[0] == &#39;H&#39;) &#123;
            qh.insert(x), qh.insert(-x);
            int r = *(qh.upper_bound(x));
            int l = -*(qh.upper_bound(-x));
            if(h[r - l]) --h[r - l];
            if(!h[r - l]) sh.erase(r - l), sh.erase(l - r);
            sh.insert(x - l), ++h[x - l];
            sh.insert(r - x), ++h[r - x];
            sh.insert(l - x), sh.insert(x - r);
        &#125; else &#123;
            qw.insert(x), qw.insert(-x);
            int r = *(qw.upper_bound(x));
            int l = -*(qw.upper_bound(-x));
            if(w[r - l]) --w[r - l];
            if(!w[r - l]) sw.erase(r - l), sw.erase(l - r);
            sw.insert(x - l), ++w[x - l];
            sw.insert(r - x), ++w[r - x];
            sw.insert(l - x), sw.insert(x - r);
        &#125;
        set&lt;int&gt;::iterator r1, r2;
        r1 = sh.begin(), r2 = sw.begin();
        printf(&quot;%lld\n&quot;, (ll)(*r1) * (*r2));
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-STLset</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 140C New Year Snowmen（堆）</title>
    <url>/2019/02/03/67/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="http://codeforces.com/problemset/problem/140/C">CodeForces</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为要保证两两不同，所以不能单纯的开堆来维护，堆维护一个二元组，个数为第一关键字，编号为第二关键字，对于一个相同的颜色，统计一下这个颜色的个数再用堆来维护就好了。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
using std::min; using std::max;
using std::sort; using std::swap;
using std::unique; using std::lower_bound;
using std::priority_queue;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 1e5 + 10;
int n, a[N], b[N], zc[N], col[N];
struct Memb &#123; int val, ind; &#125;;
struct Ans &#123; int x, y, z; &#125; A[N]; int tot;
inline bool operator &lt; (const Memb &amp;a, const Memb &amp;b) &#123; return a.val &lt; b.val; &#125;
priority_queue&lt;Memb&gt; q;

int main () &#123;
    read(n); int m = n;
    for(int i = 1; i &lt;= n; ++i)
        read(a[i]), b[i] = a[i];
    sort(&amp;b[1], &amp;b[m + 1]), m = unique(&amp;b[1], &amp;b[m + 1]) - b - 1;
    for(int i = 1; i &lt;= n; ++i) &#123;
        int tmp = lower_bound(&amp;b[1], &amp;b[m + 1], a[i]) - b;
        zc[tmp] = a[i], a[i] = tmp, ++col[tmp];
    &#125;
    for(int i = 1; i &lt;= m; ++i)
        q.push((Memb)&#123;col[i], i&#125;);
    Memb a_, b_, c_;
    while(q.size() &gt;= 3) &#123;
        a_ = q.top(); q.pop();
        b_ = q.top(); q.pop();
        c_ = q.top(); q.pop();
        A[++tot] = (Ans)&#123;zc[a_.ind], zc[b_.ind], zc[c_.ind]&#125;;
        if(--a_.val) q.push(a_);
        if(--b_.val) q.push(b_);
        if(--c_.val) q.push(c_);
    &#125;
    printf(&quot;%d\n&quot;, tot);
    for(int i = 1; i &lt;= tot; ++i) &#123;
        if(A[i].y &gt; A[i].x) swap(A[i].y, A[i].x);
        if(A[i].z &gt; A[i].y) swap(A[i].z, A[i].y);
        if(A[i].y &gt; A[i].x) swap(A[i].y, A[i].x);
        if(A[i].z &gt; A[i].y) swap(A[i].z, A[i].y);
        printf(&quot;%d %d %d\n&quot;, A[i].x, A[i].y, A[i].z);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-堆/优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj4548 小奇的糖果（链表+树状数组）</title>
    <url>/2019/02/03/66/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=4548">Bzoj</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>很显然，我们只需要考虑单独取线段上方的情况，对于下方的把坐标取反再做一遍即可（因为我们只关心最终的答案）</p>
<p>建立树状数组维护一个横坐标区间内有多少个点，维护双向链表实现查询一个点左（右）横坐标最大（小）的与它相同的点。</p>
<p>首先枚举没有取到的颜色，找出所有不包含这种颜色的区间，更新答案。</p>
<p>接着考虑两个相同颜色的点的贡献，按照纵坐标从大到小枚举所有的点,分别在树状数组和双向链表中删除当前点,并利用这个点左右两边和它颜色相同的点之间的区间内点的个数更新答案。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::sort; using std::swap;
using std::unique; using std::lower_bound;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 1e5 + 10;
int T, n, K, x[N], ans;
struct data &#123; int x, y, z, id; &#125; p[N];
int disc[N], t[N];//树状数组
int last[N], l[N], r[N];//双向链表

void add (int x, int y) &#123; while(x &lt;= n + 1) t[x] += y, x += (x &amp; -x); &#125;
int query (int x) &#123; int y = 0; while(x) y += t[x], x -= (x &amp; -x); return y; &#125;
inline bool cmpx(const data &amp;a, const data &amp;b) &#123; return a.x &lt; b.x; &#125;
inline bool cmpy(const data &amp;a, const data &amp;b) &#123; return a.y &lt; b.y; &#125;
void update(int l, int r) &#123;
    if(l &gt; r) return ;
    int tmp = query(r) - query(l - 1);
    ans = max(tmp, ans);
&#125;

void doit () &#123;
    x[0] = 0, x[n + 1] = n + 1;
    memset(last, 0, sizeof last), memset(t, 0, sizeof t);
    sort(&amp;p[1], &amp;p[n + 1], cmpx);
    for(int i = 1; i &lt;= n; ++i) add(p[i].x, 1);
    for(int i = 1; i &lt;= n; ++i) &#123;
        int t = p[i].id, L= last[p[i].z];
        l[t] = L, r[t] = n + 1;
        if(L) r[L] = t;
        update(x[L] + 1, x[t] - 1);
        last[p[i].z] = t;
    &#125;
    for(int i = 1; i &lt;= K; ++i)
        update(x[last[i]] + 1, n + 1);
    sort(&amp;p[1], &amp;p[n + 1], cmpy);
    for(int i = 1, j = 1; i &lt;= n; ++i) &#123;
        int t = p[i].id;
        while(j &lt;= n &amp;&amp; p[j].y == p[i].y) add(p[j].x, - 1), ++j;
        l[r[t]] = l[t], r[l[t]] = r[t];
        update(x[l[t]] + 1, x[r[t]] - 1);
    &#125;
&#125;

int main () &#123;
    read(T);
    while(T--) &#123;
        ans = 0, read(n), read(K); int m = n;
        for(int i = 1; i &lt;= n; ++i)
            read(p[i].x), read(p[i].y), read(p[i].z), p[i].id = i;
        for(int i = 1; i &lt;= n; ++i)
            disc[i] = p[i].x;
        sort(&amp;disc[1], &amp;disc[m + 1]), m = unique(&amp;disc[1], &amp;disc[m + 1]) - disc - 1;
        for(int i = 1; i &lt;= n; ++i) &#123;
            p[i].x = lower_bound(&amp;disc[1], &amp;disc[m + 1], p[i].x) - disc;
            x[i] = p[i].x;
        &#125;
        doit(); for(int i = 1; i &lt;= n; ++i) p[i].y = -p[i].y; doit();
        printf(&quot;%d\n&quot;, ans);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-树状数组</tag>
        <tag>[C++]数据结构-链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj1018/洛谷P4246 [SHOI2008]堵塞的交通（线段树分治+并查集）</title>
    <url>/2019/02/03/65/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=1018">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P4246">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑用并查集维护图的连通性，接着用线段树分治对每个修改进行分治。</p>
<p>具体来说，就是用一个时间轴表示图的状态，用线段树维护，对于一条边，我们判断如果他的存在时间正好在这个区间内，那就把它用并查集并起来。最后对于一个询问，直接用并查集找就好了。</p>
<p>但是因为有撤销操作，所以在并查集合并的时候，我们将需要合并的两个点放进栈中，最后栈序撤销，所以只能考虑按秩合并而不能路径压缩。</p>
<pre><code class="lang-cpp">#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::sort; using std::swap;
using std::unique; using std::lower_bound;
using std::map; using std::vector;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 2e5 + 10;
int n, id[3][N], q_num, top, fa[N], siz[N], cnt;
map&lt;int, int&gt; G[N];
struct Edge &#123; int u, v, beg, end; &#125;;
struct Node &#123; int x, y; &#125; q[N], stk[N &lt;&lt; 2];
vector&lt;Edge&gt; e;

int find(int x) &#123; while(fa[x] != x) x = fa[x]; return x; &#125;

inline void merge(int x, int y) &#123;
    int fx = find(x), fy = find(y);
    if(siz[fx] &gt; siz[fy]) swap(fx, fy);
    fa[fx] = fy, siz[fy] += siz[fx], stk[++top] = (Node)&#123;fx, fy&#125;; 
&#125;

void doit (int l, int r, vector&lt;Edge&gt; E) &#123;
    vector&lt;Edge&gt; L, R;
    int mid = (l + r) &gt;&gt; 1, tmp = top;
    for(vector&lt;Edge&gt;::iterator it = E.begin(); it != E.end(); ++it)
        if(it-&gt;beg &lt;= l &amp;&amp; it-&gt;end &gt;= r) merge(it-&gt;u, it-&gt;v);
        else &#123;
            if(it-&gt;beg &lt;= mid) L.push_back(*it);
            if(it-&gt;end &gt; mid) R.push_back(*it);
        &#125;
    if(l == r) puts(find(q[l].x) == find(q[l].y) ? &quot;Y&quot; : &quot;N&quot;);
    else doit(l, mid, L), doit(mid + 1, r, R);
    while(top &gt; tmp) &#123;
        int x = stk[top].x, y = stk[top--].y;
        fa[x] = x, siz[y] -= siz[x];
    &#125;
&#125;

int main () &#123;
    read(n);
    for(int i = 1; i &lt;= n; ++i)
        id[1][i] = ++cnt, id[2][i] = ++cnt;
    while(true) &#123;
        char s[10]; int r1, c1, r2, c2;
        scanf(&quot;%s&quot;, s); if(s[0] == &#39;E&#39;) break;
        read(r1), read(c1), read(r2), read(c2);
        if(s[0] == &#39;O&#39;) &#123;
            G[id[r1][c1]][id[r2][c2]] = G[id[r2][c2]][id[r1][c1]] = e.size();
            e.push_back((Edge)&#123;id[r1][c1], id[r2][c2], q_num + 1, -1&#125;);
        &#125; else if(s[0] == &#39;C&#39;) e[G[id[r1][c1]][id[r2][c2]]].end = q_num;
        else if(s[0] == &#39;A&#39;) q[++q_num] = (Node)&#123;id[r1][c1], id[r2][c2]&#125;;
    &#125;
    for(vector&lt;Edge&gt;::iterator it = e.begin(); it != e.end(); ++it)
        if(it-&gt;end == -1) it-&gt;end = q_num;
    for(int i = 1; i &lt;= n + n; ++i) fa[i] = i, siz[i] = 1;
    doit(1, q_num, e);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-并查集</tag>
        <tag>[C++]数据结构-线段树分治</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj2164 采矿（线段树+树链剖分）</title>
    <url>/2019/02/03/64/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=2164">Bzoj</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对于每个节点，我们可以用树链剖分和线段树维护以下信息：</p>
<ul>
<li>单独在某个点分配$i$个人的最大收益（可以$O(m)$计算）</li>
<li>分配$i$的最大收益（可以$O(m^2)$计算）</li>
</ul>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::sort; using std::swap;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 20010, M = 51, T = 65600;
int n, m, q, X = 1 &lt;&lt; 16, Y = ~0U &gt;&gt; 1, A, B, Q, op, x, y;
int fa[N], son[N], siz[N], top[N], dfn[N], dep[N], val[N], tim;
int cnt, from[N], to[N], nxt[N];
inline void addEdge(int u, int v) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], from[u] = cnt;
&#125;
struct P &#123;
    ll v[M];
    P() &#123; for(int i = 0; i &lt; M; ++i) v[i] = 0; &#125;
    P operator + (P b) &#123;
        P c;
        for(int i = 0; i &lt; M; ++i) c.v[i] = max(v[i], b.v[i]);
        return c;
    &#125;
    P operator * (P b) &#123;
        P c;
        for(int i = 0; i &lt; M; ++i)
            for(int j = 0; j &lt; M - i; ++j)
                c.v[i + j] = max(c.v[i + j], v[i] + b.v[j]);
        return c;
    &#125;
&#125;tmp, a[N], v0[T], v1[T], s0, s1;

//读入数据
inline int getint() &#123;
    A = ((A ^ B) + B / X + B * X) &amp; Y;
    B = ((A ^ B) + A / X + A * X) &amp; Y;
    return (A ^ B) % Q;
&#125;
inline void gettmp() &#123;
    for(int i = 1; i &lt;= m; ++i) tmp.v[i] = getint();
    sort(&amp;tmp.v[1], &amp;tmp.v[m + 1]);
&#125;

//线段树
inline void pushup(int o, int lc, int rc) &#123; v0[o] = v0[lc] + v0[rc], v1[o] = v1[lc] * v1[rc]; &#125;
void build(int o = 1, int l = 1, int r = n) &#123;
    if(l == r) &#123; v0[o] = v1[o] = a[val[l]]; return ; &#125;
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    build(lc, l, mid), build(rc, mid + 1, r), pushup(o, lc, rc);
&#125;
void modify(int k, int o = 1, int l = 1, int r = n) &#123;
    if(l == r) &#123; v0[o] = v1[o] = tmp; return ; &#125;
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    if(k &lt;= mid) modify(k, lc, l, mid);
    else modify(k, rc, mid + 1, r);
    pushup(o, lc, rc);
&#125;
void query0(int ql, int qr, int o = 1, int l = 1, int r = n) &#123;
    if(l &gt;= ql &amp;&amp; r &lt;= qr) &#123; s0 = s0 + v0[o]; return ; &#125;
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    if(ql &lt;= mid) query0(ql, qr, lc, l, mid);
    if(qr &gt; mid) query0(ql, qr, rc, mid + 1, r);
&#125;
void query1(int ql, int qr, int o = 1, int l = 1, int r = n) &#123;
    if(l &gt;= ql &amp;&amp; r &lt;= qr) &#123; s1 = s1 * v1[o]; return ; &#125;
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    if(ql &lt;= mid) query1(ql, qr, lc, l, mid);
    if(qr &gt; mid) query1(ql, qr, rc, mid + 1, r);
&#125;

//树链剖分
void dfs(int u) &#123;
    siz[u] = 1, dep[u] = dep[fa[u]] + 1;
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; dfs(v), siz[u] += siz[v];
        if(siz[v] &gt; siz[son[u]]) son[u] = v;
    &#125;
&#125;
void dfs(int u, int t) &#123;
    dfn[u] = ++tim, val[tim] = u, top[u] = t;
    if(!son[u]) return ; dfs(son[u], t);
    for(int i = from[u]; i; i = nxt[i])
        if(to[i] != son[u]) dfs(to[i], to[i]);
&#125;
inline void Path(int x, int y) &#123; //dep[y] 始终小于等于 dep[x]
    if(x == y) return ;
    x = fa[x]; int fx = top[x];
    while(fx != top[y]) query0(dfn[fx], dfn[x]), x = fa[fx], fx = top[x];
    query0(dfn[y], dfn[x]);
&#125;

int main () &#123;
    read(n), read(m), read(A), read(B), read(Q);
    for(int i = 2; i &lt;= n; ++i)
        read(fa[i]), addEdge(fa[i], i);
    for(int i = 1; i &lt;= n; ++i) gettmp(), a[i] = tmp;
    dfs(1), dfs(1, 1), build(), read(q);
    while(q--) &#123;
        read(op), read(x);
        if(!op) gettmp(), modify(dfn[x]);
        else &#123;
            read(y);
            s0 = s1 = P();
            Path(x, y), query1(dfn[x], dfn[x] + siz[x] - 1);
            s0 = s0 * s1;
            printf(&quot;%lld\n&quot;, s0.v[m]);
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]树论-树链剖分</tag>
        <tag>[C++]数据结构-线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj5294/洛谷P4428 [Bjoi2018]二进制（线段树）</title>
    <url>/2019/02/03/63/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=5294">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P4428">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑一个什么样的区间满足重组之后可以变成$3$的倍数。不妨设$tot$为一个区间内$1$的个数。如果$tot$是个偶数，则这个区间一定是$3$的倍数，接着考虑奇数的情况。</p>
<p>如果只有$1$个$1$，那么无论如何都不行，只需考虑$3$个$1$的情况，因为其他的$1$可以看做偶数个$1$的情况。不难发现，当只有$3$个$1$的时候，我们需要有至少$2$个$0$，接着就可以用线段树来维护了。</p>
<p>我们考虑记录三个数组，$sum[4][3], lx[4][3], rx[4][3]$，分别表示区间中的总的方案数，包含左端点的方案数，包含右端点的方案数。</p>
<p>而对于后面的二维数组，第一位表示包含$1$的个数，分别表示有零个$1$，一个$1$，有偶数（大于$0$）个$1$，有奇数（大于$1$）个一</p>
<p>二位表示$0$的个数，分别表示有零个$0$，一个$0$，以及两个及以上个$0$</p>
<p>比如说$sum[2][1]$就是表示，当前区间中，包含有偶数个$1$，并且有且仅有一个$0$的子区间的个数。</p>
<p>接着的难点就是写$pushup$了，可以参考代码。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::sort; using std::swap;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 1e5 + 10;
int n, m, x, l, r, opt, a[N];
inline int get1(int x) &#123; return (x &lt;= 1) ? x : (x % 2 + 2); &#125;
inline int get0(int x) &#123; return (x &lt;= 1) ? x : 2; &#125;
struct Matrix &#123;
    ll cnt[2], sum[4][3], lx[4][3], rx[4][3];
    Matrix operator + (const Matrix &amp; a) const &#123;
        Matrix ret, lc = *this, rc = a;
        ret.cnt[0] = lc.cnt[0] + rc.cnt[0];
        ret.cnt[1] = lc.cnt[1] + rc.cnt[1];
        for(int i = 0; i &lt; 4; ++i)
            for(int j = 0; j &lt; 3; ++j) &#123;
                ret.sum[i][j] = lc.sum[i][j] + rc.sum[i][j];
                ret.lx[i][j] = lc.lx[i][j], ret.rx[i][j] = rc.rx[i][j];
            &#125;
        for(int i1 = 0; i1 &lt; 4; ++i1)
            for(int i0 = 0; i0 &lt; 3; ++i0)
                if(lc.rx[i1][i0]) &#123;
                    ll x = lc.rx[i1][i0];
                    for(int j1 = 0; j1 &lt; 4; ++j1)
                        for(int j0 = 0; j0 &lt; 3; ++j0)
                            if(rc.lx[j1][j0]) &#123;
                                ll y = rc.lx[j1][j0];
                                ret.sum[get1(i1 + j1)][get0(i0 + j0)] += x * y;
                            &#125;
                &#125;
        int lc0 = lc.cnt[0], lc1 = lc.cnt[1];
        int rc0 = rc.cnt[0], rc1 = rc.cnt[1];
        for(int i = 0; i &lt; 4; ++i)
            for(int j = 0; j &lt; 3; ++j) &#123;
                ret.lx[get1(lc1 + i)][get0(lc0 + j)] += rc.lx[i][j];
                ret.rx[get1(rc1 + i)][get0(rc0 + j)] += lc.rx[i][j];
            &#125;
        return ret;
    &#125;
&#125; t[N &lt;&lt; 2];

inline void pushup(int o, int lc, int rc) &#123; t[o] = t[lc] + t[rc]; &#125;
void build(int o = 1, int l = 1, int r = n) &#123;
    if(l == r) &#123;
        int x = (a[l] == 1), y = (a[l] == 0);
        t[o].cnt[0] = y, t[o].cnt[1] = x;
        t[o].sum[x][y] = t[o].lx[x][y] = t[o].rx[x][y] = 1;
        return ;
    &#125; int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    build(lc, l, mid), build(rc, mid + 1, r), pushup(o, lc, rc);
&#125;
void modify(int k, int o = 1, int l = 1, int r = n) &#123;
    if(l == r) &#123;
        int x = t[o].cnt[1], y = t[o].cnt[0];
        t[o].sum[x][y] = t[o].lx[x][y] = t[o].rx[x][y] = 0;
        swap(t[o].cnt[0], t[o].cnt[1]);
        t[o].sum[y][x] = t[o].lx[y][x] = t[o].rx[y][x] = 1;
        return ;
    &#125; int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    if(k &lt;= mid) modify(k, lc, l, mid);
    else modify(k, rc, mid + 1, r);
    pushup(o, lc, rc);
&#125;
Matrix query(int ql, int qr, int o = 1, int l = 1, int r = n) &#123;
    if(l &gt;= ql &amp;&amp; r &lt;= qr) return t[o];
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    if(qr &lt;= mid) return query(ql, qr, lc, l, mid);
    else if(ql &gt; mid) return query(ql, qr, rc, mid + 1, r);
    else return query(ql, qr, lc, l, mid) + query(ql, qr, rc, mid + 1, r);
&#125;

int main () &#123;
    read(n);
    for(int i = 1; i &lt;= n; ++i) read(a[i]);
    read(m), build(); Matrix ans; ll ret;
    while(m--) &#123;
        read(opt);
        if(opt == 1) read(x), modify(x);
        else &#123;
            read(l), read(r), ans = query(l, r), ret = 0;
            ret = ans.sum[0][0] + ans.sum[0][1] + ans.sum[0][2]
                + ans.sum[2][0] + ans.sum[2][1] + ans.sum[2][2]
                + ans.sum[3][2];
            printf(&quot;%lld\n&quot;, ret);
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj4710 分特产（容斥原理+组合数）</title>
    <url>/2019/01/28/62/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=4710">Bzoj</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑容斥原理，所有人都有特产的方案数等于：</p>
<p>至少零个人没有特产$-$至少一个人没有特产$+$至少两个人有特产$-…$</p>
<p>接着考虑其中一种情况怎么求（假设现在至少有$i$个人没有特产）：</p>
<p>对于每种特产，我们分开考虑，假设当前特产有$a[j]$个，则我们可以看作是将$a[j]$个相同的球放入$n-i$个相同的盒子中，允许出现空盒（因为之前说的是至少），利用插板法，方案数为：$C_{n-i+a[j]-1}^{n-i-1}$</p>
<p>最后当前情况的贡献绝对值就是，$C[n][i]$乘上每种特产的贡献之积，$C[n][i]$表示使得$n$个同学中的$i$个没有特产。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 2e3 + 10, P = 1e9 + 7;
int n, m, a[N], c[N][N], ret;

int main () &#123;
    int lim = N - 10; c[0][0] = 1;
    for(int i = 1; i &lt;= lim; ++i) &#123;
        c[i][0] = c[i][i] = 1;
        for(int j = 1; j &lt; i; ++j)
            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % P;
    &#125;
    read(n), read(m);
    for(int i = 1; i &lt;= m; ++i) read(a[i]);
    for(int i = 0, gx = 1; i &lt;= n; ++i) &#123;
        int dq = 1;
        for(int j = 1; j &lt;= m; ++j)
            dq = 1ll * dq * c[n + a[j] - i - 1][n - i - 1] % P;
        if(gx &gt; 0) ret = (ret + 1ll * c[n][i] * dq % P) % P;
        else ret = (ret + P - 1ll * c[n][i] * dq % P) % P;
        gx = -gx;
    &#125; printf(&quot;%d\n&quot;, ret);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数论-组合数</tag>
        <tag>[C++]数论-容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj2510 弱题（矩阵快速幂）</title>
    <url>/2019/01/26/61/</url>
    <content><![CDATA[<h2 id="题面（权限题）"><a href="#题面（权限题）" class="headerlink" title="题面（权限题）"></a>题面（权限题）</h2><span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一道概率$dp$，可以设$f[i][j]$表示第$i$次操作后，标号为$j$的小球的期望个数，那么有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&f[i][j]=(1-\frac 1m)f[i-1][j]+\frac1mf[i-1][j-1](1\leq j\leq n) \\
&f[i][0]=(1-\frac 1m)f[i-1][j]+\frac1mf[i-1][n]
\end{aligned}</script><p>这样的话转移可以写成矩阵的形式（假设有$4$个小球）：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\begin{bmatrix}
f[i-1][1]&f[i-1][2]&f[i-1][3]&f[i-1][4]
\end{bmatrix}
\times
\begin{bmatrix}
1-\frac 1m&\frac 1m&0&0\\
0&1-\frac 1m&\frac 1m&0\\
0&0&1-\frac 1m&\frac 1m\\
\frac 1m&0&0&1-\frac 1m
\end{bmatrix}
\\=
&\begin{bmatrix}
f[i][1]&f[i][2]&f[i][3]&f[i][4]
\end{bmatrix}
\end{aligned}</script><p>可以发现转移矩阵也是一个循环矩阵，也就是说，可以$O(n^2log_2k)$做。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 1e3 + 10;
int n, m, k; double S[N], T[N], tmp[N];

void mul(double S[], double T[]) &#123;
    memset(tmp, 0, sizeof tmp);
    for(int i = 1; i &lt;= n; ++i)
        for(int j = 1; j &lt;= n; ++j)
            tmp[(i + j - 2) % n + 1] += S[i] * T[j];
    memcpy(S, tmp, sizeof tmp);
&#125;

int main () &#123;
    read(n), read(m), read(k);
    for(int i = 1; i &lt;= n; ++i) scanf(&quot;%lf&quot;, S + i);
    T[1] = 1 - 1.0 / m, T[2]= 1.0 / m;
    for(; k; k &gt;&gt;= 1, mul(T, T)) if(k &amp; 1) mul(S, T);
    for(int i = 1; i &lt;= n; ++i) printf(&quot;%.3lf\n&quot;, S[i]);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数论-矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈循环矩阵的乘法和快速幂</title>
    <url>/2019/01/26/60/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>前置技能：矩阵乘法，矩阵快速幂</p>
<p>当然你不会的话也不会点进来（滑稽）</p>
</blockquote>
<p>今天上午的$HNOI$模拟赛中，$T1$是这么一道题目：</p>
<span id="more"></span>
<blockquote>
<p>有一个长度为$n$的环，执行$s$次操作，在一次操作中，</p>
<p>对于每一个数，它变为它左边的数乘上$l$以及它本身以及它右边的数乘上$r$的和。</p>
<p>求最后每一个位置上的数是多少。(计算时左边和右边的数都是上一次的数)</p>
<p>最后结果模上$10^x$，$l,r,x$都为给定的常数</p>
<p>$n\leq1000,s\leq2^{30}$</p>
</blockquote>
<p>很容易想到用矩阵快速幂来维护，假设我们现在有$4$个数字需要变换，设$f[i][j]$表示当前已经变换了$i$次，第$j$位上的数字是多少，有递推式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\begin{bmatrix}
f[i-1][1]&f[i-1][2]&f[i-1][3]&f[i-1][4]
\end{bmatrix}
\times
\begin{bmatrix}
1&l&0&r\\
r&1&l&0\\
0&r&1&l\\
l&0&r&1
\end{bmatrix}
\\=
&\begin{bmatrix}
f[i][1]&f[i][2]&f[i][3]&f[i][4]
\end{bmatrix}
\end{aligned}</script><p>但是这样子做是$O(n^3log_2s)$，妥妥的超时（在没有$O(wys)$优化的情况下）</p>
<p>这时我们发现，转置矩阵是一个循环矩阵。</p>
<h2 id="循环矩阵是什么？"><a href="#循环矩阵是什么？" class="headerlink" title="循环矩阵是什么？"></a>循环矩阵是什么？</h2><p>下面内容引自百度百科，侵删</p>
<blockquote>
<p>   在线性代数中，循环矩阵是一种特殊形式的$Toeplitz$矩阵，它的行向量的每个元素都是前一个行向量各元素依次右移一个位置得到的结果。</p>
</blockquote>
<p>简单地说，就是以一行不断向前/后变换的形式出现。循环矩阵有一些性质</p>
<blockquote>
<p>假设矩阵$a,b$都是循环矩阵，那么：</p>
<ol>
<li>$a+b$是一个循环矩阵</li>
<li>$a\times b$是一个循环矩阵</li>
</ol>
</blockquote>
<h2 id="循环矩阵的矩阵快速幂"><a href="#循环矩阵的矩阵快速幂" class="headerlink" title="循环矩阵的矩阵快速幂"></a>循环矩阵的矩阵快速幂</h2><p>根据性质$2$，那么这个转置矩阵无论自乘多少次，它还是一个循环矩阵，所以说，我们理论上只要知道第一行的最终形态，就可以知道整个矩阵了。那如何求出它的下一个形态呢？（转置矩阵为$T$）</p>
<p>假设$g[i]$为当前矩阵第一行的第$i$个，$g’[i]$为下一个形态的矩阵的第$i$个。则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
g'[1]=&T[1][1]\times T[1][1]+T[1][2]\times T[2][1]
+T[1][3]\times T[3][1]+T[1][4]\times T[4][1]
\\
=&g[1]\times g[1]+g[2]\times g[4]+g[3]\times g[3]+g[4]\times g[2]
\end{aligned}</script><p>这里可以得出这个结果是根据了循环矩阵的定义。</p>
<p>那么其他的求法也是雷同的，比如$g’[2]$，其他的交给读者自己完成：</p>
<script type="math/tex; mode=display">
\begin{aligned}
g'[2]=&T[1][1]\times T[1][2]+T[1][2]\times T[2][2]
+T[1][3]\times T[3][2]+T[1][4]\times T[4][2]
\\
=&g[1]\times g[2]+g[2]\times g[1]+g[3]\times g[4]+g[4]\times g[3]
\end{aligned}</script><p>于是我们得出了这样的规律：</p>
<script type="math/tex; mode=display">
g'[x]=\sum\limits_{(i+j-2)\%n+1=x}g[i]*g[j]</script><p>很显然，我们的初始矩阵$S$也是一个只有一行的循环矩阵，同样适用于上面的规律，只不过是两个不同的矩阵。</p>
<script type="math/tex; mode=display">
tmp[x]=\sum\limits_{(i+j-2)\%n+1=x}S[i]*T[j]</script><p>其中$tmp$即本次矩阵乘法的结果矩阵</p>
<p>那么之前所讲的例题再用矩阵快速幂就变成$O(n^2log_2s)$的了：</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 1e3 + 10;
int n, s, l, r, x, p = 1;
int S[N], T[N], tmp[N];

void mul(int S[], int T[]) &#123;
    memset(tmp, 0, sizeof tmp);
    for(int i = 1; i &lt;= n; ++i)
        for(int j = 1; j &lt;= n; ++j)
            (tmp[(i + j - 2) % n + 1] += 1ll * S[i] * T[j] % p) %= p;
    memcpy(S, tmp, sizeof(tmp));
&#125;//矩阵乘法

int main () &#123;
    read(n), read(s), read(l), read(r), read(x);
    for(int i = 1; i &lt;= x; ++i) p *= 10;
    for(int i = 1; i &lt;= n; ++i) read(S[i]);
    T[1] = 1, T[2] = l, T[n] = r;
    for(; s; s &gt;&gt;= 1, mul(T, T)) if(s &amp; 1) mul(S, T);//快速幂
    for(int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, S[i]);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>[C++]数论-矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj5188/洛谷P4185 [Usaco2018 Jan]MooTube（并查集）</title>
    <url>/2019/01/24/59/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=5188">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P4185">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最暴力的方法是直接判两个点之间的路径最小值是否$\geq k$，用$Dijkstra$可以做到该算法最快效率，但是空间复杂度始终是$O(n^2)$的，会$MLE$，其实仔细观察一下，会发现对于一个满足某个$k$的路径$dis$，它一定会满足$\forall k’\leq k$，同时，对于任意一条长度大于$|dis|$的路径，它也满足又满足这些$k$，甚至更多的$k’$，于是我们从这个性质入手。</p>
<p>具体来说，就是将询问离线化，按照$k$值从大到小排序，然后将路径按照$r$值从大到小排序。线性处理询问，当处理某个询问时，将当前满足的所有边加入到并查集中，这个询问的答案就是$v$所在的并查集的$size-1$（自己本身不算），整个算法的复杂度是$O(n+m)$的。</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
using std::queue; using std::unique;
using std::lower_bound;
using std::min; using std::max;
using std::swap; using std::sort;
//typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 1e5 + 10;
int n, m, ans[N], fa[N], siz[N];
struct Edge &#123; int u, v, w; &#125; e[N];
struct Ques &#123; int k, v, id; &#125; q[N];
bool operator &lt; (const Edge &amp;a, const Edge &amp;b) &#123; return a.w &gt; b.w; &#125;
bool operator &lt; (const Ques &amp;a, const Ques &amp;b) &#123; return a.k &gt; b.k; &#125;

int find(int x) &#123; return fa[x] == -1 ? x : fa[x] = find(fa[x]); &#125;
void unionn(int x, int y) &#123;
    int fx = find(x), fy = find(y);
    if(fx == fy) return ;
    fa[fx] = fy, siz[fy] += siz[fx];
&#125;

int main () &#123;
    read(n), read(m); memset(fa, -1, sizeof fa);
    for(int i = 1; i &lt;= n; ++i) siz[i] = 1;
    for(int i = 1; i &lt; n; ++i)
        read(e[i].u), read(e[i].v), read(e[i].w);
    for(int i = 1; i &lt;= m; ++i)
        read(q[i].k), read(q[i].v), q[i].id = i;
    sort(e + 1, e + n), sort(q + 1, q + m + 1);
    for(int i = 1, j = 1; i &lt;= m; ++i) &#123;
        while(j &lt; n)
            if(e[j].w &gt;= q[i].k) unionn(e[j].u, e[j].v), ++j;
            else break;
        ans[q[i].id] = siz[find(q[i].v)];
    &#125;
    for(int i = 1; i &lt;= m; ++i) printf(&quot;%d\n&quot;, ans[i] - 1);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj1202/洛谷P2294 [HNOI2005]狡猾的商人（带权并查集/差分约束系统）</title>
    <url>/2019/01/23/58/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=1202">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P2294">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑带权并查集，设$f[i]$表示$i$的父亲（$\forall f[i]&lt;i$），$sum[i]$表示$\sum\limits_{j=fa[i]}^ia[j]$，对于一组输入的$[x,y,z]$，有：</p>
<blockquote>
<p>1.如果$f[x-1]=f[y]$</p>
</blockquote>
<p>这个时候直接判断$sum[y]-sum[x-1]$是否等于$z$就行了。</p>
<blockquote>
<p>2.如果$f[x-1]\not= f[y]$</p>
</blockquote>
<p>将$f[y]$的$f$定为$f[x-1]$，则$sum[f[y]]=sum[x-1]+z-sum[y]$</p>
<hr>
<p>如果要用差分约束系统来写，就是打板子判负/正环了，但是带权并查集更好写</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 1e2 + 10;
int t, n, m, fa[N]; ll s[N];
int find (int x) &#123;
    if(fa[x] == -1) return x;
    int tmp = find(fa[x]);
    s[x] += s[fa[x]];
    return fa[x] = tmp;
&#125;

int main () &#123;
    read(t);
    while(t--) &#123;
        bool fail = false;
        read(n), read(m);
        memset(fa, -1, sizeof fa);
        memset(s, 0, sizeof s);
        int x, y; ll z;
        for(int i = 1; i &lt;= m; ++i) &#123;
            read(x), read(y), read(z), --x;
            int fx = find(x), fy = find(y);
            if(fx == fy) &#123;
                if(s[y] - s[x] != z) &#123;
                    fail = true; break;
                &#125;
            &#125; else fa[fy] = fx, s[fy] = s[x] + z - s[y];
        &#125;
        puts(fail ? &quot;false&quot; : &quot;true&quot;);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-带权并查集</tag>
        <tag>[C++]图论-差分约束系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj2002/洛谷P3203 [HNOI2010]弹飞绵羊（分块）</title>
    <url>/2019/01/22/57/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=2002">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P3203">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><del>大力分块</del>，分块大小$\sqrt n$，对于每一个元素记一下跳多少次能跳到下一个块，以及跳到下一个块的哪个位置，修改的时候时候只需要更新元素所在的那一块即可，然后询问也是$\sqrt n$的模拟。</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
using std::__gcd;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 2e5 + 10, SN = 450, M = 1e5 + 10;
int n, m, k[N], x, y, siz, out[N], step[N];
int bel[N], l[SN], r[SN];

void doit (int L, int R) &#123;
    for(int i = R; i &gt;= L; --i) &#123;
        int nxt = i + k[i];
        if(nxt &gt; R) step[i] = 1, out[i] = nxt;
        else step[i] = step[nxt] + 1, out[i] = out[nxt];
    &#125;
&#125;

int main () &#123;
    read(n), siz = sqrt(n);
    for(int i = 1; i &lt;= n; ++i)
        read(k[i]), bel[i] = (i - 1) / siz + 1;
    for(int i = 1; i &lt;= bel[n]; ++i) &#123;
        l[i] = r[i - 1] + 1, r[i] = min(i * siz, n);
        doit(l[i], r[i]);
    &#125;
    read(m); int opt;
    while(m--) &#123;
        read(opt), read(x), ++x;
        if(opt == 1) &#123;
            int ret = 0;
            while(x &lt;= n) ret += step[x], x = out[x];
            printf(&quot;%d\n&quot;, ret);
        &#125; else read(k[x]), doit(l[bel[x]], r[bel[x]]);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-分块</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj2152/洛谷P2634 聪聪可可（点分治）</title>
    <url>/2019/01/22/56/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=2152">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P2634">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>点分治套路走一波，考虑$calc$函数怎么写，存一下每条路径在$\%3$意义下的路径总数，假设为$tot[i]$即$\equiv i(mod\ 3)$，这时当前的贡献就是$tot[0]^2+2\times tot[1]\times tot[2]$。</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
using std::__gcd;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 2e4 + 10, Inf = 1e9 + 7;
int n, m, k, d[N], Size, ans, tot[4];
int cnt, from[N], to[N &lt;&lt; 1], nxt[N &lt;&lt; 1], dis[N &lt;&lt; 1];
int p, siz[N], tmp; bool vis[N];
inline void addEdge(int u, int v, int w) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], dis[cnt] = w, from[u] = cnt;
&#125;

void getrt(int u, int f) &#123;
    siz[u] = 1; int max_part = 0;
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; if(v == f || vis[v]) continue;
        getrt(v, u), siz[u] += siz[v];
        max_part = max(max_part, siz[v]);
    &#125; max_part = max(max_part, Size - siz[u]);
    if(max_part &lt; tmp) tmp = max_part, p = u;
&#125;

void getpoi(int x, int y, int f) &#123;
    ++tot[y];
    for(int i = from[x]; i; i = nxt[i]) &#123;
        int v = to[i]; if(v == f || vis[v]) continue;
        getpoi(v, (y + dis[i]) % 3, x);
    &#125;
&#125;

void calc (int x, int y, int dd) &#123;
    memset(tot, 0, sizeof tot);
    getpoi(x, y % 3, 0);
    ans += dd * (tot[0] * tot[0] + 2 * tot[1] * tot[2]);
&#125;

void doit(int x) &#123; 
    tmp = Inf, getrt(x, 0), vis[p] = true;
    calc(p, 0, 1);
    for(int i = from[p]; i; i = nxt[i]) &#123;
        int v = to[i]; if(vis[v]) continue;
        calc(v, dis[i], -1);
        Size = siz[v], doit(v);
    &#125;
&#125;

int main () &#123;
    read(n), Size = n;
    for(int i = 1, u, v, w; i &lt; n; ++i) &#123;
        read(u), read(v), read(w);
        addEdge(u, v, w), addEdge(v, u, w);
    &#125; doit(1);
    int m = n * n, gg = __gcd(m, ans);
    printf(&quot;%d/%d\n&quot;, ans / gg, m / gg);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj3261/洛谷P4735 最大异或和（可持久化Trie）</title>
    <url>/2019/01/22/55/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=3261">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P4735">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然，如果让你查询整个数列的最大异或和，建一颗$01Trie$，每给定一个$p$，按照二进制后反方向跳就行了（比如当前二进制位为$1$，则往$0$跳，反之亦反）。</p>
<p>但是现在要支持在最末尾插入和区间查询，将这颗$Trie$可持久化一下就好了（可持久化$Trie$敲板）</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::sort; using std::swap;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 6e5 + 10;
int trie[N * 24][2], latest[N * 24];
int s[N], rt[N], n, m, tot;

void insert(int i, int k, int p, int q) &#123; // q -&gt; p s[i][k]
    if(k &lt; 0) &#123; latest[q] = i; return ; &#125;
    int c = (s[i] &gt;&gt; k) &amp; 1;
    if(p) trie[q][c ^ 1] = trie[p][c ^ 1];
    trie[q][c] = ++tot;
    insert(i, k - 1, trie[p][c], trie[q][c]);
    latest[q] = max(latest[trie[q][0]], latest[trie[q][1]]);
&#125;

int query(int now, int val, int k, int limit) &#123;
    if(k &lt; 0) return s[latest[now]] ^ val;
    int c = (val &gt;&gt; k) &amp; 1;
    if(latest[trie[now][c ^ 1]] &gt;= limit)
        return query(trie[now][c ^ 1], val, k - 1, limit);
    else return query(trie[now][c], val , k - 1, limit);
&#125;

int main () &#123;
    read(n), read(m);
    latest[0] = -1, rt[0] = ++tot;
    insert(0, 23, 0, rt[0]);
    for(int i = 1; i &lt;= n; ++i) &#123;
        int x; read(x);
        s[i] = s[i - 1] ^ x, rt[i] = ++tot;
        insert(i, 23, rt[i - 1], rt[i]);
    &#125;
    for(int i = 1; i &lt;= m; ++i) &#123;
        char opt[3]; scanf(&quot;%s&quot;, opt);
        if(opt[0] == &#39;A&#39;) &#123;
            int x; read(x);
            rt[++n] = ++tot, s[n] = s[n - 1] ^ x;
            insert(n, 23, rt[n - 1], rt[n]);
        &#125; else &#123;
            int l, r, x; read(l), read(r), read(x);
            printf(&quot;%d\n&quot;, query(rt[r - 1], x ^ s[n], 23, l - 1));
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-可持久化Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>Poj1741/洛谷P4718 Tree（点分治）</title>
    <url>/2019/01/22/54/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>有多组数据：<a href="http://poj.org/problem?id=1741">Poj</a></p>
<p>无多组数据：<a href="https://www.luogu.org/problemnew/show/P4178">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>点分治板子题，$calc$的时候搞一个$two\ pointers$扫一下统计答案就行了。</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 1e4 + 10, Inf = 1e9 + 7;
int n, k, d[N], Size;
int cnt, from[N], to[N &lt;&lt; 1], nxt[N &lt;&lt; 1], dis[N &lt;&lt; 1];
int p, siz[N], tmp; bool vis[N];
inline void addEdge(int u, int v, int w) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], dis[cnt] = w, from[u] = cnt;
&#125;

void getrt(int u, int f) &#123;
    siz[u] = 1; int max_part = 0;
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; if(v == f || vis[v]) continue;
        getrt(v, u), siz[u] += siz[v];
        max_part = max(max_part, siz[v]);
    &#125; max_part = max(max_part, Size - siz[u]);
    if(max_part &lt; tmp) tmp = max_part, p = u;
&#125;

void getpoi(int x, int y, int f) &#123;
    d[++tmp] = y;
    for(int i = from[x]; i; i = nxt[i]) &#123;
        int v = to[i]; if(v == f || vis[v]) continue;
        getpoi(v, y + dis[i], x);
    &#125;
&#125;

int calc (int x, int y) &#123;
    tmp = 0, getpoi(x, y, 0);
    sort(&amp;d[1], &amp;d[tmp + 1]);
    int j = tmp, ret = 0;
    for(int i = 1; i &lt; j; ++i) &#123;
        while(d[i] + d[j] &gt; k &amp;&amp; i &lt; j) --j;
        ret += j - i;
    &#125; return ret;
&#125;

int doit(int x) &#123;
    int ret = 0; 
    tmp = Inf, getrt(x, 0), vis[p] = true;
    ret += calc(p, 0);
    for(int i = from[p]; i; i = nxt[i]) &#123;
        int v = to[i]; if(vis[v]) continue;
        ret -= calc(v, dis[i]), Size = siz[v], ret += doit(v);
    &#125; return ret;
&#125;

int main () &#123;
    while(1) &#123;
        read(n), read(k); if(!n &amp;&amp; !k) break;
        Size = n, cnt = 0, memset(from, 0, sizeof from);
        memset(vis, 0, sizeof vis);
        for(int i = 1, u, v, w; i &lt; n; ++i) &#123;
            read(u), read(v), read(w);
            addEdge(u, v, w), addEdge(v, u, w);
        &#125;
        printf(&quot;%d\n&quot;, doit(1));
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj2038/洛谷P1494 小Z的袜子（莫队）</title>
    <url>/2019/01/22/53/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=2038">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P1494">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑莫队算法，首先对询问进行分块（分块大小为$sqrt(n)$），对于同一个块内的询问，按照左端点为第一关键字，右端点为第二关键字排序。我们统计这个区间内相同的颜色有多少个，假设某种颜色$i$有$j$个，则贡献就是$j\times(j-1)$，最后记得化成既约分数。</p>
<pre><code class="lang-cpp">#include &lt;set&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;
using std::set;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 5e4 + 10, M = 5e4 + 10;
int n, m, c[N], siz, blo, t, l, r, v[N];
struct Ques &#123; int x, y, z; &#125; q[M], b[M];
inline bool cmp1 (Ques a, Ques b) &#123; return a.x &lt; b.x; &#125;
inline bool cmp2 (Ques a, Ques b) &#123; return a.y &lt; b.y; &#125;
ll up[M], down[M], _gcd, tmp;
template&lt;typename T&gt;
T gcd(T a, T b) &#123; return b ? gcd(b, a % b) : a; &#125;

void modify (int st, int ed, int flag) &#123;
    for(int i = st; i &lt; ed; ++i) &#123;
        tmp -= 1ll * v[c[i]] * (v[c[i]] - 1);
        v[c[i]] += flag;
        tmp += 1ll * v[c[i]] * (v[c[i]] - 1);
    &#125;
&#125;

int main () &#123;
#ifdef OFFLINE_JUDGE
    freopen(&quot;233.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;233.out&quot;, &quot;w&quot;, stdout);
#endif
    read(n), read(m);
    for(int i = 1; i &lt;= n; ++i) read(c[i]);
    for(int i = 1; i &lt;= m; ++i)
        read(q[i].x), read(q[i].y), q[i].z = i;
    sort(&amp;q[1], &amp;q[m + 1], cmp1);
    siz = sqrt(n), blo = (n / siz) + (n % siz != 0);
    for(int i = 0, j = 1; i &lt; blo; ++i) &#123;
        t = 0;
        while(j &lt;= m &amp;&amp; q[j].x &gt; i * siz &amp;&amp; q[j].x &lt;= (i + 1) * siz) b[++t] = q[j++];
        sort(&amp;b[1], &amp;b[t + 1], cmp2);
        l = b[1].x, r = b[1].x - 1, tmp = 0;
        memset(v, 0, sizeof v);
        for(int k = 1; k &lt;= t; ++k) &#123;
            if(b[k].x == b[k].y) &#123;
                up[b[k].z] = 0, down[b[k].z] = 1;
                continue;
            &#125;
            if(l &lt; b[k].x) modify(l, b[k].x, -1);
            else if(l &gt; b[k].x) modify(b[k].x, l, 1);
            if(r &lt; b[k].y) modify(r + 1, b[k].y + 1, 1);
            else if(r &gt; b[k].y) modify(b[k].y + 1, r + 1, -1);
            up[b[k].z] = tmp, down[b[k].z] = b[k].y - b[k].x + 1;
            l = b[k].x, r = b[k].y;
        &#125;
    &#125;
    for(int i = 1; i &lt;= m; ++i) &#123;
        if(!down[i] || !up[i]) &#123; puts(&quot;0/1&quot;); continue; &#125;
        down[i] = down[i] * (down[i] - 1);
        tmp = gcd(up[i], down[i]);
        printf(&quot;%lld/%lld\n&quot;, up[i] / tmp, down[i] / tmp);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj2120/洛谷P1903 数颜色（莫队）</title>
    <url>/2019/01/22/52/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=2120">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P1903">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑对操作离线后分块处理询问操作（莫队算法），将询问操作按照编号分块后左端点第一关键字，右端点第二关键字排序（分块大小为$n^{\frac 23}$），对于每一个询问操作，记下当前最后一个修改操作。</p>
<p>之后就是莫队的板子了。</p>
<pre><code class="lang-cpp">#include &lt;set&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;
using std::set;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 2e6 + 10, M = 5e4 + 10;
int n, m, siz, col[M], l, r, tot[N], ans[M], ret, now, bel[M];
struct Ques &#123; int x, y, z, pre; &#125; q[M]; int cntqu;
struct Modi &#123; int pos, val; &#125; o[M]; int cntmo;
inline bool cmp (const Ques &amp;a, const Ques &amp;b) &#123;
    if(bel[a.z] != bel[b.z]) return bel[a.z] &lt; bel[b.z];
    if(a.x != b.x) return a.x &lt; b.x;
    if(a.y != b.y) return a.y &lt; b.y;
    return a.pre &lt; b.pre;
&#125;

inline void del (int c) &#123; if(--tot[c] == 0) --ret; &#125;
inline void add (int c) &#123; if(++tot[c] == 1) ++ret; &#125;
inline void doit (int now, int k) &#123;
    if(o[now].pos &gt;= q[k].x &amp;&amp; o[now].pos &lt;= q[k].y)
        del(col[o[now].pos]), add(o[now].val);
    swap(col[o[now].pos], o[now].val);
    //将操作记忆化，当处理替换时，相当于换过去，撤销时，相当于换回来。
&#125;

int main () &#123;
    read(n), read(m), siz = pow(n, 0.66666666);
    for(int i = 1; i &lt;= n; ++i)
        read(col[i]), bel[i] = (i - 1) / siz + 1;
    char opt;
    while(m--) &#123;
        scanf(&quot;\n%c&quot;, &amp;opt);
        if(opt == &#39;Q&#39;) &#123;
            read(q[++cntqu].x), read(q[cntqu].y);
            q[cntqu].z = cntqu, q[cntqu].pre = cntmo;
        &#125; else read(o[++cntmo].pos), read(o[cntmo].val); 
    &#125;
    sort(&amp;q[1], &amp;q[cntqu + 1], cmp), l = 1;
    for(int i = 1; i &lt;= cntqu; ++i) &#123;
        while(l &lt; q[i].x) del(col[l++]);
        while(l &gt; q[i].x) add(col[--l]);
        while(r &lt; q[i].y) add(col[++r]);
        while(r &gt; q[i].y) del(col[r--]);
        while(now &lt; q[i].pre) doit(++now, i);
        while(now &gt; q[i].pre) doit(now--, i);
        ans[q[i].z] = ret;
    &#125;
    for(int i = 1; i &lt;= cntqu; ++i)
        printf(&quot;%d\n&quot;, ans[i]);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>Poj2482 Stars in Your Window（扫描线）</title>
    <url>/2019/01/22/51/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="http://poj.org/problem?id=2482">Poj</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><blockquote>
<p>下面内容引用自”李煜东 《算法竞赛进阶指南》”（对原文略有缩减，侵删）：</p>
<p>因为矩形的大小固定，所以矩形可以由它的任意一个顶点唯一确定。我们可以考虑把<strong>矩形的右上角顶点放在什么位置</strong>，圈住的星星亮度总和最大。</p>
<p>所以，对于一颗星星，能够覆盖住这颗星星的右上角的位置在区间$[x,y]-[x+w,y+h]$之间，但是由于边界上的星星不算，所以不妨将星星变为$[x-0.5,y-0.5]$，于是右上角变为$[x+w-1,y+h-1]$。</p>
<p>问题就转化成了：<strong>平面上有若干个区域，每个区域都带有一个权值，求在哪个坐标上重叠的区域权值和最大</strong>。可以用扫描线算法来解决。</p>
<p>具体来说，将一颗星星抽象成一个矩形，取出左右边界（四元组）：$(x,y,y+h-1,c)$和$(x+w,y,y+h-1,-c)$，然后按照横坐标排序。关于纵坐标建立一颗线段树，维护区间最大值$dat$，初始全为$0$，线段树上的一个值$y$表示区间$[y,y+1]$，注意扫描每个四元组$(x,y_1,y_2,c)$，执行区间修改，把$[y1,y2]$中的每一个数都加$c$，用根节点$dat$更新就好了。</p>
</blockquote>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
using std::unique; using std::lower_bound;
typedef long long ll;
#define int ll

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 2e4 + 10;
ll n, W, H;
ll cf[N &lt;&lt; 1], tot;
struct star &#123; ll x, y, h; &#125; s[N];
struct raw &#123; ll x, y1, y2, d; &#125; cy[N &lt;&lt; 1]; int cnt;
inline bool cmp (const raw &amp;a ,const raw &amp;b) &#123; return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.d &lt; b.d); &#125;
ll val[N &lt;&lt; 4], add[N &lt;&lt; 4];

void pushdown(int o, int lc, int rc) &#123;
    if(add[o]) &#123;
        add[lc] += add[o], add[rc] += add[o];
        val[lc] += add[o], val[rc] += add[o], add[o] = 0;
    &#125;
&#125;

void modify (int ml, int mr, ll k, int o = 1, int l = 1, int r = tot) &#123;
    if(l &gt;= ml &amp;&amp; r &lt;= mr) &#123; val[o] += k, add[o] += k; return ; &#125;
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    pushdown(o, lc, rc);
    if(ml &lt;= mid) modify(ml, mr, k, lc, l, mid);
    if(mr &gt; mid) modify(ml, mr, k, rc, mid + 1, r);
    val[o] = max(val[lc], val[rc]);
&#125;

signed main () &#123;
    while(scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;W, &amp;H) != EOF) &#123;
        cnt = tot = 0; ll ans = 0;
        for(int i = 1; i &lt;= n; ++i) &#123;
            read(s[i].x), read(s[i].y), read(s[i].h);
            cy[++cnt] = (raw)&#123;s[i].x, s[i].y, s[i].y + H - 1, s[i].h&#125;;
            cy[++cnt] = (raw)&#123;s[i].x + W, s[i].y, s[i].y + H - 1, -s[i].h&#125;;
            cf[++tot] = s[i].y, cf[++tot] = s[i].y + H - 1;
        &#125; sort(&amp;cf[1], &amp;cf[tot + 1]), tot = unique(&amp;cf[1], &amp;cf[tot + 1]) - cf - 1;
        sort(&amp;cy[1], &amp;cy[cnt + 1], cmp);
        memset(val, 0, sizeof val), memset(add, 0, sizeof add);
        for(int i = 1; i &lt;= cnt; ++i) &#123;
            cy[i].y1 = lower_bound(&amp;cf[1], &amp;cf[tot + 1], cy[i].y1) - cf;
            cy[i].y2 = lower_bound(&amp;cf[1], &amp;cf[tot + 1], cy[i].y2) - cf;
            modify(cy[i].y1, cy[i].y2, cy[i].d);
            ans = max(ans, val[1]);
        &#125;
        printf(&quot;%lld\n&quot;, ans);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]计算几何-扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>Poj2182 Lost Cows（玄学算法）</title>
    <url>/2019/01/22/50/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="http://poj.org/problem?id=2182">Poj</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>不难发现最后一位就是$pre[n]+1$，然后消除这个位置对其他位置的贡献，从左到右扫一遍，必定有至少一个位置可以得出，循环这个过程，$O(n^2)$出解。</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

const int N = 8e4 + 10;
int n, pre[N], a[N], less[N];
bool used[N];

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) ch = getchar();
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar();
&#125;

int main () &#123;
    read(n);
    for(int i = 2; i &lt;= n; ++i) read(pre[i]), less[i] = i - 1;
    a[n] = pre[n] + 1, used[a[n]] = true;
    for(int i = a[n] + 1; i &lt;= n; ++i) --less[i];
    for(int i = n - 1; i &gt;= 1; --i) &#123;
        for(int j = 1; j &lt;= n; ++j)
            if(less[j] == pre[i] &amp;&amp; !used[j]) &#123; a[i] = j, used[a[i]] = true; break; &#125;;
        for(int j = a[i] + 1; j &lt;= n; ++j) --less[j];
    &#125;
    for(int i = 1; i &lt;= n; ++i)
        printf(&quot;%d\n&quot;, a[i]);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]玄学算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Poj3468 A Simple Problem with Integers （分块）</title>
    <url>/2019/01/22/49/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="http://poj.org/problem?id=3468">Poj</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>区间求和$+$区间修改板子，这里用分块写的</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;
#define int ll

const int N = 1e5 + 10 , SN = 340;
int n, siz, q, bel[N], val[N];
int sum[SN], add[SN], L[SN], R[SN];

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

void modify (int l, int r, int c) &#123;
    int fl = bel[l], fr = bel[r];
    if(fl == fr) &#123;
        for(int i = l; i &lt;= r; ++i)
            val[i] += c, sum[fl] += c;
    &#125; else &#123;
        for(int i = l; i &lt;= R[fl]; ++i)
            val[i] += c, sum[fl] += c;
        for(int i = fl + 1; i &lt; fr; ++i) add[i] += c;
        for(int i = L[fr]; i &lt;= r; ++i)
            val[i] += c, sum[fr] += c;
    &#125;
&#125;

int query(int l, int r) &#123;
    int fl = bel[l], fr = bel[r], ret = 0;
    if(fl == fr) &#123;
        for(int i = l; i &lt;= r; ++i)
            ret += val[i] + add[fl];
    &#125; else &#123;
        for(int i = l; i &lt;= R[fl]; ++i)
            ret += val[i] + add[fl];
        for(int i = fl + 1; i &lt; fr; ++i) ret += sum[i] + add[i] * (R[i] - L[i] + 1);
        for(int i = L[fr]; i &lt;= r; ++i)
            ret += val[i] + add[fr];
    &#125; return ret;
&#125;

signed main () &#123;
    read(n), read(q), siz = sqrt(n);
    for(int i = 1; i &lt;= n; ++i)
        read(val[i]), bel[i] = (i - 1) / siz + 1, sum[bel[i]] += val[i];
    for(int i = 1; i &lt;= bel[n]; ++i)
        L[i] = R[i - 1] + 1, R[i] = i * siz;
    R[bel[n]] = n; int l, r, k;
    while(q--) &#123;
        char opt; scanf(&quot;\n%c&quot;, &amp;opt);
        read(l), read(r);
        if(opt == &#39;Q&#39;) printf(&quot;%lld\n&quot;, query(l, r));
        else read(k), modify(l, r, k);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-分块</tag>
      </tags>
  </entry>
  <entry>
    <title>Poj1182 食物链（并查集/带权并查集）</title>
    <url>/2019/01/22/48/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="http://poj.org/problem?id=1182">Poj</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这里采用并查集的补集。</p>
<p>$x$表示同类集合，$x+n$表示敌人集合，$x+n\times2$表示敌人的敌人集合。</p>
<blockquote>
<p>如果当前给出的是一对同类关系，就判断$x$是否吃$y$或者$y$是否吃$x$（冲突）。</p>
<p>如果是真话，就将所有关系连在一起。</p>
<p>反之，如果给出的是一对$x$吃$y$关系，就判断$x$是否吃了自己（矛盾）或者他们两个互相吃（冲突）。</p>
<p>如果是真话，将$x$的敌人和$y$的敌人的敌人（朋友）连在一起，将$y$的敌人和$x$的敌人的敌人（朋友）连在一起，即$y$的敌人是$x$的朋友，将$y$丢进$x$的敌人集合中。</p>
</blockquote>
<p>上面这对话可能有点绕口，但是大概还是讲出来了，仔细理解一下吧…</p>
<p>这里还有一个带权并查集的做法，但是并查集补集更好写（写起来更顺些）。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define Rg register 

const int N = 5e4 + 10;
int n, k, fa[N * 3], cz, x, y, ans, nn;

int find (int x) &#123;
    if (fa[x] != x) fa[x] = find (fa[x]);
    return fa[x];
&#125;

int unionn (int u, int v) &#123;
    int fu = find (u), fv = find (v);
    fa[fv] = fu;
&#125;//v -&gt; u

int main () &#123;
    scanf (&quot;%d%d&quot;, &amp;n, &amp;k);
    nn = n * 3;
    for (Rg int i = 1; i &lt;= nn; ++i)
        fa[i] = i;
    while (k--) &#123;
        scanf (&quot;%d%d%d&quot;, &amp;cz, &amp;x, &amp;y);
        if (x &gt; n || y &gt; n) &#123;++ans; continue;&#125;//依据2
        if (cz == 1) &#123;
            if (find (x + n) == find(y) || find (y + n) == find (x)) &#123;++ans; continue;&#125;//依据1
            unionn (x, y); unionn (x + n, y + n); unionn (x + (n &lt;&lt; 1), y + (n &lt;&lt; 1));
        &#125; else &#123;
            if (find (x) == find (y) || find (x) == find (y + n)) &#123;++ans; continue;&#125;//依据1&amp;依据3
            unionn (y + (n &lt;&lt; 1), x); unionn (y, x + n); unionn (y + n, x + (n &lt;&lt; 1));
        &#125;
    &#125;
    printf (&quot;%d\n&quot;, ans);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-并查集</tag>
        <tag>[C++]数据结构-带权并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Poj1733 Parity Game（带权并查集）</title>
    <url>/2019/01/22/47/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="http://poj.org/problem?id=1733">Poj</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>反正只要你判断是否满足区间的奇偶性，假设每一位要么是$1$要么是$0$好了。</p>
<p>假设有$S$的前缀和为$sum[]$，则有：</p>
<blockquote>
<p>若$S[l…r]$中有奇数个$1$，则$sum[l-1]$与$sum[r]$不同奇偶；反之，则同奇偶</p>
</blockquote>
<p>用一个带权并查集维护，设权值数组$s[i]$表示区间$[root[i]…i]$的和的奇偶性。</p>
<p>对于一个区间$[l,r]$，分情况讨论：</p>
<blockquote>
<p>如果$root[l]=root[r]$，直接判断就行了。</p>
<p>否则的话，计算一下$s[fv]=t\oplus s[u]\oplus s[v]$</p>
</blockquote>
<p>但是$n$太大了，需要离散化（懒人离散化用$map$，美滋滋）</p>
<pre><code class="lang-cpp">#include &lt;map&gt; 
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using std::map;
typedef long long ll;

const ll N = 1e4 + 10, Q = 5e3 + 10;
ll n, q, s[N], f[N], cnt;
map &lt;ll, ll&gt; m;

ll find (ll x) &#123;
    if(f[x] == -1) return x;
    ll tmp = find(f[x]);
    s[x] ^= s[f[x]];
    return f[x] = tmp;
&#125;

ll insert (ll x) &#123;
    if (m.find(x) == m.end()) m[x] = ++cnt;
    return m[x];
&#125;

int main() &#123;
    while (scanf (&quot;%lld%lld&quot;, &amp;n, &amp;q) != EOF) &#123;
        char str[4];
        memset(f, -1, sizeof f);
        memset(s, 0, sizeof s);
        ll ans = q;
        for (register ll i = 1, u, v; i &lt;= q; ++i) &#123;
            scanf (&quot;%lld%lld%s&quot;, &amp;u, &amp;v, str);
            if (ans &lt; q) continue;
            u = insert(u - 1), v = insert(v);
            ll fu = find(u), fv = find(v);
            ll t = 0;
            if (str[0] == &#39;o&#39;) ++t;
            if (fu == fv) &#123;  //root相等
                if (s[u] ^ s[v] != t)
                    ans = i - 1;
            &#125; else &#123; //一定有fu&lt;fv(编号比较)
                f[fv] = fu;
                s[fv] = s[u] ^ s[v] ^ t;
                //矢量的异或运算
            &#125;
        &#125;
        printf (&quot;%lld\n&quot;, ans);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-带权并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj1015/洛谷P1197 [JSOI2008]星球大战（并查集）</title>
    <url>/2019/01/22/46/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=1015">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P1197">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑离线做法，逆序处理，一个一个星球的加入。用并查集维护一下连通性就好了。</p>
<p>具体来说，先将被消灭的星球储存下来，先将没有被消灭的星球用并查集并在一起，这样做可以路径压缩，然后再将被消灭的星球倒着一个一个加入，然后在$union$的时候，如果两个元素不在同一个集合中，答案减一（最初答案为$n$），将每一阶段的答案存下来就行了。</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

const int N = 4e5 + 10, M = 2e5 + 10;
int n, m, from[N], fa[N], ans[N], top, ret;
bool vis[N];
struct Edge &#123; int to, nxt; &#125; e[M &lt;&lt; 1]; int cnt;
inline void addEdge(int u, int v) &#123;
    e[++cnt] = (Edge)&#123;v, from[u]&#125;, from[u] = cnt;
&#125;
int bro[N], k;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) ch = getchar();
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar();
&#125;

int find(int x) &#123; return fa[x] == x ? x : (fa[x] = find(fa[x])); &#125;
void unionn(int x, int y) &#123; //x -&gt; y; 
    int fx = find(x), fy = find(y);
    if(fx != fy) --ret, fa[fx] = fy;
&#125;

int main () &#123;
#ifdef OFFLINE_JUDGE
    freopen(&quot;233.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;233.out&quot;, &quot;w&quot;, stdout);
#endif
    read(n), read(m), ret = n;
    for(int i = 0; i &lt; n; ++i) fa[i] = i;
    for(int i = 1, u, v; i &lt;= m; ++i) &#123;
        read(u), read(v);
        addEdge(u, v), addEdge(v, u);
    &#125; read(k), top = k;
    for(int i = 1; i &lt;= k; ++i)
        read(bro[i]), vis[bro[i]] = true;
    for(int u = 0; u &lt; n; ++u)
        if(!vis[u])
            for(int i = from[u]; i; i = e[i].nxt)
                if(!vis[e[i].to])
                    unionn(u, e[i].to);
    ans[top--] = ret;
    for(int i = k; i &gt;= 1; --i) &#123;
        int u = bro[i];
        for(int i = from[u]; i; i = e[i].nxt)
            if(!vis[e[i].to])
                unionn(u, e[i].to);
        vis[u] = false, ans[top--] = ret;
    &#125;
    for(int i = 0; i &lt;= k; ++i)
        printf(&quot;%d\n&quot;, ans[i] - i);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Loj#6434「PKUSC2018」主斗地（搜索）</title>
    <url>/2019/01/18/45/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://loj.ac/problem/6434">Loj</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>细节比较多的搜索题。</p>
<p>首先现将牌型暴力枚举出来，大概是$3^{16}$吧。</p>
<p>然后再看能打什么，简化后无非就三种决策：单牌，$3+x$和$4+x$。</p>
<p>枚举网友打了几张$3$和$4$，然后再枚举吉老师（$\mathbf {orz}$）打了几张$3$和$4$。</p>
<p>接着枚举$3$搭配了几个$2$，然后贪心地从大到小去除吉老师手中大小为$2$的对子，从小到大去除网友手中大小为$2$的对子。之后就是检查单牌是否合法了。</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int _ = 20;
char s[_];
int ans, cnt[_], a[_], orz[_];
int wy[_], jtkl[_], thr[_], fou[_], W[_], J[_], P[_];

int code (char c)&#123;
    switch(c) &#123;
    case &#39;T&#39;: return 7;
    case &#39;J&#39;: return 8;
    case &#39;Q&#39;: return 9;
    case &#39;K&#39;: return 10;
    case &#39;A&#39;: return 11;
    case &#39;2&#39;: return 12;
    case &#39;w&#39;: return 13;
    case &#39;W&#39;: return 14;
    default: return c - &#39;4&#39; + 1;
    &#125;
&#125;

bool check(int f, int t) &#123;
    for(int i = 0; i &lt;= t; ++i) &#123;
        memcpy(W, wy, sizeof wy), memcpy(J, jtkl, sizeof jtkl);
        if(2 * i + t - i + f * 2  + f * 4 + t * 3 &gt; 17) break;
        int cnt = 0;
        for(int j = 1; j &lt;= 14; ++j) &#123;
            if(W[j] &gt;= 2 &amp;&amp; cnt &lt; i) W[j] -= 2, ++cnt;
            if(W[j] &gt;= 2 &amp;&amp; cnt &lt; i) W[j] -= 2, ++cnt;
            if(cnt == i) break;
        &#125;
        if(cnt &lt; i) break; cnt = 0;
        for(int j = 14; j &gt;= 1; --j) &#123;
            if(J[j] &gt;= 2 &amp;&amp; cnt &lt; i) J[j] -= 2, ++cnt;
            if(J[j] &gt;= 2 &amp;&amp; cnt &lt; i) J[j] -= 2, ++cnt;
            if(cnt == i) break;
        &#125;
        if(cnt &lt; i) break;
        memset(P, 0, sizeof P);
        cnt = 2 * f + t - i;
        for(int j = 14; j &gt;= 1; --j) &#123;
            int t = min(cnt, J[j]);
            J[j] -= t, cnt -= t;
            if(!cnt) break;
        &#125;
        if(cnt) continue;
        cnt = 2 * f + t - i;
        for(int j = 1; j &lt;= 14; ++j) &#123;
            int t = min(cnt, W[j]);
            W[j] -= t, cnt -= t;
            if(!cnt) break;
        &#125;
        if(J[14]) continue;
        for(int j = 1; j &lt;= 14; ++j)
            P[j] += W[j], P[j + 1] -= J[j];
        cnt = 0;
        for(int j = 1; j &lt;= 14; ++j) &#123;
            cnt += P[j];
            if(cnt &gt; 0) break;
        &#125;
        if(!cnt) return true;
    &#125; return false;
&#125;

bool check_jtkl(int now, int four, int three, int f, int t, int q1, int q2) &#123;
    if(four == f &amp;&amp; three == t) return check(f, t);
    if(now &gt;= 12) return false;
    q1 += thr[now], q2 += fou[now];
    if(q1 &gt; 0 || q2 &gt; 0) return false;
    if(jtkl[now] &gt;= 3) &#123;
        jtkl[now] -= 3;
        if(check_jtkl(now + 1, four, three, f, t + 1, q1 - 1, q2)) return true;
        jtkl[now] += 3;
    &#125;
    if(jtkl[now] &gt;= 4) &#123;
        jtkl[now] -= 4;
        if(check_jtkl(now + 1, four, three, f + 1, t, q1, q2 - 1)) return true;
        jtkl[now] += 4;
    &#125;
    return check_jtkl(now + 1, four, three, f, t, q1, q2);
&#125;

bool check_wy (int now, int four, int three) &#123;
    if(four * 6 + three * 4 &gt; 17) return false;
    if(now &gt; 12) return check_jtkl(1, four, three, 0, 0, 0, 0);
    if(wy[now] &gt;= 3) &#123;
        wy[now] -= 3, ++thr[now];
        if(check_wy(now + 1, four, three + 1)) return true;
        wy[now] += 3, --thr[now];
    &#125;
    if(wy[now] &gt;= 4) &#123;
        wy[now] -= 4, ++fou[now];
        if(check_wy(now + 1, four + 1, three)) return true;
        wy[now] += 4, --fou[now];
    &#125;
    return check_wy(now + 1, four, three);
&#125;

void dfs(int now, int rest) &#123;
    if(!rest) &#123;
        memset(thr, 0, sizeof thr);
        memset(fou, 0, sizeof fou);
        memcpy(wy, a, sizeof a);
        memcpy(jtkl, orz, sizeof orz);
        if(check_wy(2, 0, 0)) ++ans;
        return ;
    &#125;
    if(now &gt; 14) return ;
    for(int i = 0; i &lt;= cnt[now]; ++i) &#123;
        if(i &gt; rest) break;
        orz[now] = i, dfs(now + 1, rest - i), orz[now] = 0;
    &#125;
&#125;

int main () &#123;
    while(scanf(&quot;%s&quot;, s + 1) != EOF) &#123;
        memset(a, 0, sizeof a);
        for(int i = 1; i &lt;= 12; ++i) cnt[i] = 4;
        cnt[13] = cnt[14] = 1, ans = 0;
        for(int i = 1; i &lt;= 17; ++i)
            ++a[code(s[i])], --cnt[code(s[i])];
        dfs(1, 17), printf(&quot;%d\n&quot;, ans);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]算法思想-搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Loj#6433「PKUSC2018」最大前缀和（状态压缩DP）</title>
    <url>/2019/01/18/44/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://loj.ac/problem/6433">Loj</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先转化题意，其实这题在乘了$n!$以后就变成了全排列中的最大前缀和的和（有点拗口）。$n\leq20$，考虑状压$DP$</p>
<p>考虑一个最大前缀和$\sum\limits_{i=1}^pa_i$。</p>
<p>这个位置$p$是最大前缀和的右界当且仅当对$\forall r&gt;p$有：$\sum\limits_{i=p+1}^ra_i\leq0$</p>
<hr>
<p>设$sum_i$表示二进制状态$i$的代数和，方便转移</p>
<p>设$g_i$表示选了子集$i$后有多少种排列使得所有的前缀和都$&lt;0$，于是有（从下转移而来）：</p>
<script type="math/tex; mode=display">
g[i] += g[i \oplus (1 << j)]\ (sum[i]\leq0,sum[i\oplus(1<<j)]\leq0)</script><p>设$f_i$表示选了子集$i$后有多少种排列使得最大前缀和$=sum_i$，于是有（向上转移）：</p>
<script type="math/tex; mode=display">
f[i \ | \ (1 << j)]+=f[i]\ (sum[i]>0)</script><p>则最后答案就是（$m\oplus i$表示$i$的补集）：</p>
<script type="math/tex; mode=display">
ans=\sum_{i\in S}sum_i\times f_i \times g_{m\oplus i}</script><pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 22, P = 998244353;
int n, m, a[1 &lt;&lt; N], f[1 &lt;&lt; N], g[1 &lt;&lt; N], sum[1 &lt;&lt; N], ret;
int lb(int x) &#123; return x &amp; -x; &#125;

int main () &#123;
    read(n), m = (1 &lt;&lt; n) - 1;
    for(int i = 0; i &lt; n; ++i) read(a[1 &lt;&lt; i]);
    for(int i = 0; i &lt;= m; ++i)
        sum[i] = sum[i ^ lb(i)] + a[lb(i)];
    g[0] = 1;
    for(int i = 0; i &lt; n; ++i) f[1 &lt;&lt; i] = 1;
    for(int i = 0; i &lt;= m; ++i) &#123;
        if(sum[i] &lt;= 0) &#123;
            for(int j = 0; j &lt; n; ++j)
                if((1 &lt;&lt; j) &amp; i &amp;&amp; sum[i ^ (1 &lt;&lt; j)] &lt;= 0)
                    (g[i] += g[i ^ (1 &lt;&lt; j)]) %= P;
        &#125; 
    &#125;
    for(int i = 0; i &lt;= m; ++i) &#123;
        if(sum[i] &gt; 0) &#123;
            for(int j = 0; j &lt; n; ++j)
                if(!((1 &lt;&lt; j) &amp; i)) (f[i | (1 &lt;&lt; j)] += f[i]) %= P;
        &#125;
        (ret += 1ll * (sum[i] + P) % P * f[i] % P * g[m ^ i] % P) %= P;
    &#125;
    printf(&quot;%d\n&quot;, ret);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]动态规划-状态压缩DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Loj#6432「PKUSC2018」真实排名（二分查找+组合数）</title>
    <url>/2019/01/18/43/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://loj.ac/problem/6432">Loj</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>普通的暴力是直接枚举改或者不改，最后在判断最后对哪些点有贡献。</p>
<p>而这种方法是很难优化的。所以考虑在排序之后线性处理。首先先假设没有重复的元素</p>
<pre><code class="lang-cpp">struct Node &#123; int poi, id; &#125; a[N];
bool operator &lt; (const Node &amp;a, const Node &amp;b) &#123; return a.poi &lt; b.poi; &#125;
bool operator &lt; (const Node &amp;a, const int &amp;b) &#123; return a.poi &lt; b; &#125;
bool operator &lt; (const int &amp;a, const Node &amp;b) &#123; return a &lt; b.poi; &#125;

int main() &#123;
    read(n);
    for(int i = 1; i &lt;= n; ++i) read(a[i].poi), a[i].id = i;
    sort(a + 1, a + n + 1);
&#125;
</code></pre>
<p>对于一个点，我们同样是枚举它改或者不改，但是，接着我们来判断哪些点的变化可以对这个点产生贡献，</p>
<hr>
<p><strong>决策1：不改</strong></p>
<p>不改的话，那么这个元素后面的元素不管变还是不变都可以产生贡献，假设当前处理到$i$，则其后面有$n-i$个元素。</p>
<p>接着考虑前面的元素，前面的元素改变可以对它产生贡献当且仅当它小于$a_i/2$。这里可以使用二分查找。假设一共有$site$个元素满足上面这个条件。</p>
<p>则这个决策所产生的贡献为：$C_{n-i+site}^k$</p>
<hr>
<p><strong>决策2：改</strong></p>
<p>当这个元素改的时候，怎么保证它的$rank$不变呢？那么就要保证区间$[a_i,2a_i]$这个区间内的所有数字都要变。同样可以二分来确定这个区间内有多少个元素。假设右界为$tmp$，则有$tot=tmp-i+1$个元素是必须要变的</p>
<p>则这个决策所产生的贡献为：$C_{n-tot}^{k-tot}$</p>
<hr>
<p><strong>重复的元素</strong></p>
<p>之前的所有决策都是在元素不重复的情况下计算的贡献。那么当元素重复时，怎么计算呢？假设现在同一个元素已经出现了$cf$次。</p>
<p>考虑不改的决策，由于$rank$的含义是大于等于它的数不变，所以这个决策的贡献变为：$C_{n-i+site+cf-1}^k$</p>
<p>接着考虑改变的决策，同样，根据$rank$的定义，这些重复的数字也需要改变。所以$tot$变为：</p>
<script type="math/tex; mode=display">
tot=tmp-i+1+cf-1=tmp-i+cf</script><hr>
<p>接着还有一些细节，比如对于$0$的特判（直接就是$C(n,k)$）之类的</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::lower_bound;
using std::upper_bound;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 1e5 + 10, P = 998244353;
int n, k, ret[N], fac[N], inv[N];
struct Node &#123; int poi, id; &#125; a[N];
bool operator &lt; (const Node &amp;a, const Node &amp;b) &#123; return a.poi &lt; b.poi; &#125;
bool operator &lt; (const Node &amp;a, const int &amp;b) &#123; return a.poi &lt; b; &#125;
bool operator &lt; (const int &amp;a, const Node &amp;b) &#123; return a &lt; b.poi; &#125;
inline void add(int &amp;x) &#123; ++x; if(x == P) x = 0; &#125;

int find(double val, int site) &#123;
    int l = 1, r = site - 1, ret = 0;
    while(l &lt;= r) &#123;
        int mid = (l + r) &gt;&gt; 1;
        if(1. * a[mid].poi &lt; val) ret = mid, l = mid + 1;
        else r = mid - 1; 
    &#125; return ret;
&#125;

int C(int n, int m) &#123;
    if(n &lt; m) return 0;
    return (int)(1ll * (1ll * fac[n] * inv[m] % P) * inv[n - m] % P);
&#125;

int qpow(int a, int b) &#123;
    int ret = 1;
    for(; b; b &gt;&gt;= 1, a = 1ll * a * a % P) if(b &amp; 1) ret = 1ll * ret * a % P;
    return ret;
&#125;

int main () &#123;
    read(n), read(k), fac[0] = inv[0] = 1;
    for(int i = 1; i &lt;= n; ++i) fac[i] = 1ll * fac[i - 1] * i % P;
    inv[n] = qpow(fac[n], P - 2);
    for(int i = n; i &gt;= 1; --i) inv[i - 1] = 1ll * inv[i] * i % P;
    for(int i = 1; i &lt;= n; ++i) read(a[i].poi), a[i].id = i;
    sort(a + 1, a + n + 1);
    for(int i = 1, cf = 0; i &lt;= n; ++i) &#123;
        if(a[i].poi == 0) &#123; ret[a[i].id] = C(n, k); continue; &#125;
        int site = find(1. * a[i].poi / 2., i);
        if(a[i].poi == a[i - 1].poi) ++cf;
        else cf = 1;
        (ret[a[i].id] += C(site + n - i + cf - 1, k)) %= P;//改的决策
        int tmp = lower_bound(a + i + 1, a + n + 1, a[i].poi * 2) - a - 1;
        if(tmp != -1) &#123;
            int tot = tmp - i + cf;
            if(k &gt;= tot) (ret[a[i].id] += C(n - tot, k - tot)) %= P;
        &#125;//不改的决策
    &#125;
    for(int i = 1; i &lt;= n; ++i) printf(&quot;%d\n&quot;, ret[i]);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数论-组合数</tag>
        <tag>[C++]算法思想-二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4587 [FJOI2016]神秘数（主席树）</title>
    <url>/2019/01/17/42/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://www.luogu.org/problemnew/show/P4587">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑暴力，对于询问中的一段区间$[l,r]$，我们先将其中的数升序排序，假设当前可以表示出$[1,k]$目前处理$a_i$，假如$a_i&gt;k+1$，则答案就是$k+1$，否则，调整右界到$k+a_i$。</p>
<p>考虑如何优化，还是扫到了$[1,k]$，假设$ans=k+1$，如果所有小于等于$ans$的数的和$sum$起来大于等于$ans$，则一定可以将$k$更新成$sum$。否则直接输出就好了。</p>
<p>以上这个过程很明显可以用主席树维护，统计一个区间内小于等于某个数的数的和。</p>
<p>接着来证明一下这个东西的复杂度。什么时候对于这种算法，复杂度最劣呢？就是，对于一个区间$[l,r]$，排完序后有：</p>
<script type="math/tex; mode=display">
a_i=\sum_{j=l}^{i-1}a_j(l\leq i\leq r)</script><p>比如：$1,1,2,4,8,16,…,2^k$，所以说，这个算法的复杂度是$log_2(\sum a_i)$，而$\sum a_i\leq10^9$，所以所以是对的</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
using std::unique; using std::lower_bound;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 1e5 + 10, Inf = 1e9 + 7;
int n, q, a[N], rt[N], poi;
int val[N &lt;&lt; 5], lson[N &lt;&lt; 5], rson[N &lt;&lt; 5];
ll sum[N &lt;&lt; 5];

int insert(int o, int l, int r, int k) &#123;
    int o_ = ++poi;
    lson[o_] = lson[o], rson[o_] = rson[o], sum[o_] = sum[o] + k;
    if (l == r) return o_;
    int mid = (l + r) &gt;&gt; 1;
    if (k &lt;= mid) lson[o_] = insert(lson[o_], l, mid, k);
    else rson[o_] = insert(rson[o_], mid + 1, r, k);
    return o_;
&#125;

ll query (int x, int y, int l, int r, int k) &#123;
    if(l == r) return sum[y] - sum[x];
    int mid = (l + r) &gt;&gt; 1; 
    if(k &lt;= mid) return query(lson[x], lson[y], l, mid, k);
    else return sum[lson[y]] - sum[lson[x]] +
             query(rson[x], rson[y], mid + 1, r, k);
&#125;

int main () &#123;
    read(n);
    for(int i = 1; i &lt;= n; ++i)
        read(a[i]), rt[i] = insert(rt[i - 1], 1, Inf, a[i]);
    read(q); int x, y;
    while(q--) &#123;
        read(x), read(y);
        ll MX = 1, ans = 0;
        ans = query(rt[x - 1], rt[y], 1, Inf, int(MX));
        while(ans &gt;= MX &amp;&amp; MX != Inf) &#123;
            MX = min(1ll * Inf, ans + 1);
            ans = query(rt[x - 1], rt[y], 1, Inf, int(MX));
        &#125; printf(&quot;%lld\n&quot;, ans + 1);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-可持久化线段树/主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4609 [FJOI2016]建筑师（第一类斯特林数+组合数）</title>
    <url>/2019/01/17/41/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://www.luogu.org/problemnew/show/P4609">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><img src="https://s2.ax1x.com/2019/01/17/kpikPf.jpg" alt=""></p>
<p>(图片来源于网络，侵删)</p>
<p>以最高的柱子$n$为分界线，我们将左边的一个柱子和它右边的省略号看作一个圆排列，右边的一个柱子和它左边的省略号看作一个圆排列，于是，除了中间的最高的柱子，我们可以把剩下的$n-1$根柱子放入这$A+B-2$（左边$A-1$个右边$B-1$个）个圆排列中（第一类斯特林数），然后在根据组合数进行区分，有：</p>
<script type="math/tex; mode=display">
ans=s_{n-1}^{A+B-2}\times C_{A+B-2}^{A-1}</script><p>预处理第一类斯特林和组合数即可。</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 5e4 + 10, M = 2e2 + 10;
const int P = 1e9 + 7;
int t, n, a, b;
int C[M][M], s[N][M];

int main () &#123;
    read(t);
    for(int i = 0; i &lt; M; ++i) &#123;
        C[i][i] = C[i][0] = 1;
        for(int j = 1; j &lt; i; ++j)
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;
    &#125;
    for(int i = 0; i &lt; N; ++i) &#123;
        if(i &lt; M) s[i][i] = 1;
        for(int j = 1; j &lt; i &amp;&amp; j &lt; M; ++j)
            s[i][j] = (1ll * s[i - 1][j] * (i - 1) % P + 1ll * s[i - 1][j - 1]) % P;
    &#125;
    while(t--) &#123;
        read(n), read(a), read(b);
        if(a + b &gt; n + 1) &#123; puts(&quot;0&quot;); continue; &#125;
        printf(&quot;%lld\n&quot;, 1ll * s[n - 1][a + b - 2] * C[a + b - 2][a - 1] % P);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数论-第一类斯特林数</tag>
        <tag>[C++]数论-组合数</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj4016/洛谷P2993 [FJOI2014] 最短路径树问题（最短路径问题+长链剖分/点分治）</title>
    <url>/2019/01/17/40/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=4016">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P2993">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先把最短路径树建出来（用$Dijkstra$，没试过$SPFA$$\leftarrow$它死了），然后问题就变成了一个关于深度的问题，可以用长链剖分做，所以我们用点分治来做（滑稽）。</p>
<p>有一点要说，这一题数据比较水，如果不用字典序的话，也可以过。如何建立字典序呢？其实我们从$1$号节点开始遍历路径树（不是最短路径树），令一个点的第一关键字是点权，如果点权相等就按照编号大小为第二关键字，维护一个二元组就好了。</p>
<p>点分治时记两个数组$S[i]$和$num[i]$，表示经过$i$个点的路径最大是多少以及在这个情况下有多少条路径。</p>
<p>之前找重心调了好久。</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;iostream&gt;
using std::pair; using std::sort;
using std::priority_queue;
using std::vector; using std::greater;
typedef long long ll;
typedef pair&lt;int, int&gt; pii;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 3e4 + 10, Inf = 1 &lt;&lt; 30;
int n, m, k, from[N], dist[N], MX, tot;
int cnt, to[N &lt;&lt; 1], nxt[N &lt;&lt; 1], dis[N &lt;&lt; 1];
bool vis[N];
vector&lt;pii&gt; G[N]; priority_queue&lt; pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q;
void addEdge(int u, int v, int w) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], dis[cnt] = w, from[u] = cnt;
&#125;

void dijk(int s) &#123;
    memset(dist, 0x7777777f, sizeof dist);
    dist[s] = 0, q.push((pii)&#123;0, s&#125;);
    while(q.size()) &#123;
        int u = q.top().second; q.pop();
        if(vis[u]) continue; vis[u] = true;
        for(int i = 0; i &lt; G[u].size(); ++i) &#123;
            int v = G[u][i].first, w = G[u][i].second + dist[u];
            if(dist[v] &gt; w) dist[v] = w, q.push((pii)&#123;dist[v], v&#125;);
        &#125;
    &#125;
&#125;

void init(int u) &#123;
    vis[u] = 1;
    for(int i = 0; i &lt; G[u].size(); ++i) &#123;
        int v = G[u][i].first, w = G[u][i].second;
        if(vis[v] || w + dist[u] != dist[v]) continue;
        addEdge(u, v, w), addEdge(v, u, w), init(v);
    &#125;
&#125;

int Size, tmp, p, siz[N], maxnow, S[N], num[N];
inline void upt(int &amp;a, int b) &#123; if(a &lt; b) a = b; &#125;

void getrt(int u, int f) &#123; 
    int max_part = 0; siz[u] = 1;
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; if(vis[v] || v == f) continue;
        getrt(v, u); siz[u] += siz[v];
        upt(max_part, siz[v]);
    &#125; upt(max_part, Size - siz[u]);
    if(max_part &lt; tmp) p = u, tmp = max_part;
&#125;

void calc(int u, int f, int now) &#123;
    upt(maxnow, now);
    if(now == k - 1) &#123;
        if(dist[u] == MX) ++tot;
        else if(dist[u] &gt; MX) MX = dist[u], tot = 1;
        return ;
    &#125;
    int nowans = -1;
    if(S[k - 1 - now] != -1) nowans = dist[u] + S[k - 1 - now];
    if(nowans == MX) tot += num[k - 1 - now];
    else if(nowans &gt; MX) MX = nowans, tot = num[k - 1 - now];
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; if(vis[v] || v == f) continue;
        dist[v] = dist[u] + dis[i], calc(v, u, now + 1);
    &#125;
&#125;

void update(int u, int f, int now) &#123;
    if(now == k - 1) return ;
    if(S[now] == dist[u]) ++num[now];
    else upt(S[now], dist[u]), num[now] = 1;
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; if(vis[v] || v == f) continue;
        update(v, u, now + 1);
    &#125;
&#125;

void doit(int x) &#123;
    p = 0, tmp = Inf, getrt(x, 0), vis[p] = 1, maxnow = 0;
    for(int i = from[p]; i; i = nxt[i]) &#123;
        int v = to[i]; if(vis[v]) continue;
        dist[v] = dis[i], calc(v, p, 1), update(v, p, 1);
    &#125;
    for(int i = 1; i &lt;= maxnow; ++i) S[i] = -1, num[i] = 0;
    for(int i = from[p]; i; i = nxt[i]) &#123;
        int v = to[i]; if(vis[v]) continue;
        Size = siz[v], doit(v);
    &#125;
&#125;

int main () &#123;
    read(n), read(m), read(k);
    for(int i = 1, u, v, w; i &lt;= m; ++i) &#123;
        read(u), read(v), read(w);
        G[u].push_back((pii)&#123;v, w&#125;);
        G[v].push_back((pii)&#123;u, w&#125;);
    &#125;
    for(int i = 1; i &lt;= n; ++i) sort(G[i].begin(), G[i].end());
    dijk(1), memset(vis, 0, sizeof vis), init(1);
    Size = n, memset(vis, 0, sizeof vis);
    memset(dist, 0, sizeof dist), doit(1);
    printf(&quot;%d %d\n&quot;, MX, tot);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-点分治</tag>
        <tag>[C++]图论-最短路径问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj1486/洛谷P3199 最小圈（0/1分数规划+spfa）/（动态规划+结论）</title>
    <url>/2019/01/11/39/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=1486">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P3199">洛谷</a></p>
<span id="more"></span>
<h2 id="题解（0-1分数规划-spfa）"><a href="#题解（0-1分数规划-spfa）" class="headerlink" title="题解（0/1分数规划+spfa）"></a>题解（0/1分数规划+spfa）</h2><p>考虑$0/1$分数规划，设当前枚举到的答案为$ans$</p>
<p>则我们要使（其中$\forall b_i=1$）</p>
<script type="math/tex; mode=display">
\frac{\sum_{i=1}^ta[e_i]}{\sum_{i=1}^tb[v_i]}< ans
\\ \therefore\sum a[e_i]-ans*b[v_i]=\sum a[e_i]-ans<0</script><p>则问题就变成了判断图内是否存在一个负环…</p>
<p>时间复杂度:$O(nmlog)$</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 3e3 + 10, M = 1e4 + 10;
const double eps = 1e-9;
int n, m, from[N], cnt, to[M], nxt[M]; double dis[M];
inline void addEdge(int u, int v, double w) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], dis[cnt] = w, from[u] = cnt;
&#125;
double p[N]; bool vis[N], flag;

void spfa(int u, double k) &#123;
    vis[u] = 1;
    for(int i = from[u]; i; i = nxt[i]) &#123;
        if(flag) return ;
        int v = to[i]; double w = dis[i] - k;
        if(p[v] &gt; p[u] + w) &#123;
            if(vis[v]) return (void)(flag = 1);
            p[v] = p[u] + w, spfa(v, k);
        &#125;
    &#125;
    vis[u] = 0;
&#125;

int main () &#123;
    read(n), read(m); int u, v; double w;
    for(int i = 1; i &lt;= m; ++i)
        read(u), read(v), scanf(&quot;%lf&quot;, &amp;w), addEdge(u, v, w);
    double l = -1e7, r = 1e7, ret;
    while(r - l &gt; eps) &#123;
        double mid = l + (r - l) / 2.; 
        memset(p, 0, sizeof p), memset(vis, 0, sizeof vis);
        flag = 0;
        for(int i = 1; i &lt;= n; ++i) &#123;
            spfa(i, mid); if(flag) break;
        &#125;
        if(flag) ret = mid, r = mid - eps;
        else l = mid + eps;
    &#125; printf(&quot;%.8lf\n&quot;, ret);
    return 0;
&#125;
</code></pre>
<h2 id="题解（动态规划-结论）"><a href="#题解（动态规划-结论）" class="headerlink" title="题解（动态规划+结论）"></a>题解（动态规划+结论）</h2><p>显然，如果真的将渐进复杂度卡满的话（甚至卡到指数级），你是过不去的，这里讲一下这题真正意义上的正解（貌似出这道题的本意就是考察$0/1$分数规划）。</p>
<p>为什么说是结论呢？根据Karp在1977年的论文，他讲述了一种$O(nm)$的算法，用来求有向强连通图中最小平均权值回路，也就是这题的模型。具体可以去看$_rqy$的<a href="http://www.cnblogs.com/y-clever/p/7043553.html">博客</a></p>
<p>我们新建一个节点，从它到每个点连一条权值任意的边（比如都是$0$），再令$F_j(i)$表示从新建的点到$i$点恰好经过$j$条边的最短路，那么有</p>
<script type="math/tex; mode=display">
ans=\min_{1\leq i\leq n, F_{n+1}(i)\neq\infty}\max_{j=1}^{n}\left[\frac{F_{n+1}(v)-F_k(v)}{n+1-k}\right]</script><p>求$f$可以用动态规划来求，之后就是套公式了。</p>
<p>但是啊，在$Bzoj$上是过不去的，空间只有$64MB$，可以用滚动数组进行优化。</p>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数论-0/1分数规划</tag>
        <tag>[C++]图论-负环</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj4753/洛谷P4432 [JSOI2016]最佳团体（0/1分数规划+树形DP）</title>
    <url>/2019/01/11/38/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=4753">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P4322">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这种求比值最大就是$0/1$分数规划的一般模型。</p>
<p>这里用二分法来求解最大比值，接着考虑如何$check$，这里很明显可以想到用树形背包$check$，但是时间复杂度要优化成$O(n^2)$的，可以参考之前写的这篇<a href="https://www.cnblogs.com/water-mi/p/9818622.html">博客</a></p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using std::min;
using std::max;

const int N = 3e3 + 10, inf = 1e9 + 7;
const double eps = 1e-5;
int n, K, s[N], p[N], son[N][N], dfn[N], time, nx[N];
int from[N], to[N], nxt[N], cnt;//Edges
double f[N][N], d[N];

inline void addEdge (int u, int v) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], from[u] = cnt;
&#125;

inline void upt(double &amp;a, double b) &#123;
    if (a &lt; b) a = b;
&#125;

void dfs (int u) &#123;
    dfn[u] = time++;
    for (int i = from[u]; i; i = nxt[i]) dfs(to[i]);
    nx[dfn[u]] = time;
&#125;

inline bool check (double k) &#123;
    for (int i = 1; i &lt;= n; ++i) 
        d[dfn[i]] = p[i] - k * s[i];
    for (int i = 1; i &lt;= n + 1; ++i)
        for (int j = 0; j &lt;= K; ++j)
            f[i][j] = -inf;
    for (int i = 0; i &lt;= n; ++i)
        for (int j = 0; j &lt;= min(i, K); ++j) &#123;
            upt(f[i + 1][j + 1], f[i][j] + d[i]);
            upt(f[nx[i]][j], f[i][j]);
        &#125;
    return f[n + 1][K] &gt;= eps;
&#125;

int main () &#123;
    scanf(&quot;%d%d&quot;, &amp;K, &amp;n); ++K;
    for (int i = 1, fa; i &lt;= n; ++i)  &#123;
        scanf(&quot;%d%d%d&quot;, s + i, p + i, &amp;fa);
        addEdge(fa, i);
    &#125;
    dfs(0);
    double l = 0, r = 10000, ans;
    while (r - l &gt;= eps) &#123;
        double mid = (l + r) * 0.5;
        if (check(mid)) ans = mid, l = mid + eps;
        else r = mid - eps;
    &#125;
    printf (&quot;%.3lf\n&quot;, ans);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]动态规划-树形DP</tag>
        <tag>[C++]动态规划-背包DP</tag>
        <tag>[C++]数论-0/1分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj3197/洛谷3296 [SDOI2013]刺客信条assassin（树的重心+树Hash+树形DP+KM）</title>
    <url>/2019/01/11/37/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=3197">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P3296">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先固定一棵树,枚举另一棵树,显然另一棵树只有与这棵树同构才有可能产生贡献<br>如果固定的树以重心为根,那么另一棵树最多就只有重心为根才有可能同构了(可能有两个)<br>然后就是求改动次数最小值,设$f[x][y]$表示以第一棵树$x$为根的子树内和第二棵树内$y$为根的子树内,达到目标最少需要改动的次数<br>我们发现只有同构的子树需要决策,我们把同构的子树分别拿出来,我们要做的就是做一个匹配,跑一遍$KM$或者费用流就好了。因为要最小化$f[x][y]$，所以是跑最小完美匹配。<br>$f[x][y]$要记忆化一下,判断同构用树哈希即可</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::sort; using std::vector;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 1.4e3 + 10, Inf = 1e9 + 7;
void upt0(int &amp;x, int y) &#123; if(x &lt; y) x = y; &#125;
void upt1(int &amp;x, int y) &#123; if(x &gt; y) x = y; &#125;

namespace KM &#123;
    int n, w[N][N], match[N], ret, lx[N], ly[N];
    bool visx[N], visy[N];
    bool Hungary(int x) &#123;
        visx[x] = 1;
        for(int y = 1; y &lt;= n; ++y)
            if(!visy[y] &amp;&amp; lx[x] + ly[y] == w[x][y]) &#123;
                visy[y] = true;
                if(!match[y] || Hungary(match[y])) &#123; match[y] = x; return 1; &#125;
            &#125; 
        return 0;
    &#125;
    int main(int opt) &#123;
        for(int i = 1; i &lt;= n; ++i)
            for(int j = 1; j &lt;= n; ++j)
                w[i][j] = opt * w[i][j];
        for(int i = 1; i &lt;= n; ++i) &#123;
            lx[i] = -Inf, ly[i] = 0;
            for(int j = 1; j &lt;= n; ++j) upt0(lx[i], w[i][j]);
        &#125;
        memset(match, 0, sizeof match);
        for(int x = 1; x &lt;= n; ++x)
            while(1) &#123;
                memset(visx, 0, sizeof visx), memset(visy, 0, sizeof visy);
                if(Hungary(x)) break;
                int inc = Inf;
                for(int i = 1; i &lt;= n; ++i)
                    if(visx[i])
                        for(int j = 1; j &lt;= n; ++j)
                            if(!visy[j]) upt1(inc, lx[i] + ly[j] - w[i][j]);
                for(int i = 1; i &lt;= n; ++i) &#123;
                    if(visx[i]) lx[i] -= inc;
                    if(visy[i]) ly[i] += inc;
                &#125;
            &#125;
        for(int i = 1; i &lt;= n; ++i)
            if(match[i]) ret += w[match[i]][i];
        return opt * ret;
    &#125;
&#125;//KM模板

int n, rt, fir[N], sec[N], f[N][N], c[N][N]; ll hash[N];
int from[N], cnt, to[N &lt;&lt; 1], nxt[N &lt;&lt; 1];
inline void addEdge(int u, int v) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], from[u] = cnt;
&#125;
int tmp, siz[N];
vector&lt;int&gt; v1[N], v2[N];
inline bool cmp(const int &amp;i, const int &amp;j) &#123; return hash[i] &lt; hash[j]; &#125;

void getrt(int u, int fa) &#123;
    int max_part = 0; siz[u] = 1;
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; if(v == fa) continue;
        getrt(v, u), siz[u] += siz[v], upt0(max_part, siz[v]);
    &#125; upt0(max_part, n - siz[u]);
    if(max_part &lt; tmp) tmp = max_part, rt = u;
&#125;//寻找树的重心

void dfs(int u, int fa, vector&lt;int&gt; *V) &#123;
    siz[u] = 1, hash[u] = 0, V[u].clear();
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; if(v == fa) continue;
        dfs(v, u, V), siz[u] += siz[v], V[u].push_back(v);
    &#125; sort(V[u].begin(), V[u].end(), cmp);
    for(int i = V[u].size() - 1; ~i; --i)
        hash[u] = hash[u] * N + hash[V[u][i]];
    hash[u] = hash[u] * N + siz[u];
&#125;//处理各子树hash值以及儿子（将儿子放进一个vector里面）

int dp(int x, int y) &#123;
    if(f[x][y] != -1) return f[x][y];
    f[x][y] = fir[x] ^ sec[y]; int lim = v1[x].size() - 1;
    for(int i = 0; i &lt;= lim; ++i) &#123;
        int j = i;
        while(j &lt; lim &amp;&amp; hash[v1[x][j + 1]] == hash[v1[x][i]]) ++j;
        for(int k = i; k &lt;= j; ++k)
            for(int l = i; l &lt;= j; ++l)
                dp(v1[x][k], v2[y][l]);
        for(int k = i; k &lt;= j; ++k)
            for(int l = i; l &lt;= j; ++l)
                KM::w[k - i + 1][l - i + 1] = dp(v1[x][k], v2[y][l]);
        //初始化边权
        KM::ret = 0, KM::n = j - i + 1, f[x][y] += KM::main(-1), i = j;
        //最小化f[x][y]
    &#125; return f[x][y];
&#125;

int main () &#123;
    read(n);
    for(int i = 1, u, v; i &lt; n; ++i)
        read(u), read(v), addEdge(u, v), addEdge(v, u);
    for(int i = 1; i &lt;= n; ++i) read(fir[i]);
    for(int i = 1; i &lt;= n; ++i) read(sec[i]);
    tmp = Inf, getrt(1, 0), dfs(rt, 0, v2); ll tmp = hash[rt];
    int ans = Inf;
    for(int i = 1; i &lt;= n; ++i) &#123;//暴力枚举重心
        dfs(i, 0, v1);
        if(hash[i] == tmp) memset(f, -1, sizeof f), upt1(ans, dp(i, rt));
    &#125; printf(&quot;%d\n&quot;, ans);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]动态规划-树形DP</tag>
        <tag>[C++]图论-二分图</tag>
        <tag>[C++]树论-树的重心</tag>
        <tag>[C++]算法思想-哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>关于二分图的完美匹配问题</title>
    <url>/2019/01/11/36/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>占坑</p>
<span id="more"></span>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
using std::__gcd;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 3e2 + 10, Inf = 1e9 + 7;
int n, w[N][N], match[N], ret;
int lx[N], ly[N];//定点标号
bool visx[N], visy[N];
void upt0(int &amp;x, int y) &#123; if(x &lt; y) x = y; &#125;
void upt1(int &amp;x, int y) &#123; if(x &gt; y) x = y; &#125;

bool Hungary(int x) &#123;
    visx[x] = 1;
    for(int y = 1; y &lt;= n; ++y) &#123;
        if(!visy[y] &amp;&amp; lx[x] + ly[y] == w[x][y]) &#123;
            visy[y] = true;
            if(!match[y] || Hungary(match[y])) &#123; match[y] = x; return 1; &#125;
        &#125; 
    &#125; return 0;
&#125;

int KM() &#123;
    for(int i = 1; i &lt;= n; ++i) &#123;
        lx[i] = -Inf, ly[i] = 0;
        for(int j = 1; j &lt;= n; ++j) upt0(lx[i], w[i][j]);
    &#125;
    memset(match, 0, sizeof match);
    for(int x = 1; x &lt;= n; ++x)
        while(1) &#123;
            memset(visx, 0, sizeof visx), memset(visy, 0, sizeof visy);
            if(Hungary(x)) break;
            int inc = Inf;//增量标记
            for(int i = 1; i &lt;= n; ++i)
                if(visx[i])
                    for(int j = 1; j &lt;= n; ++j)
                        if(!visy[j]) upt1(inc, lx[i] + ly[j] - w[i][j]);
            for(int i = 1; i &lt;= n; ++i) &#123;
                if(visx[i]) lx[i] -= inc;
                if(visy[i]) ly[i] += inc;
            &#125;
        &#125;
    for(int i = 1; i &lt;= n; ++i)
        if(match[i]) ret += w[match[i]][i];
    return ret;
&#125;

int main () &#123;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF) &#123;
        for(int i = 1; i &lt;= n; ++i)
            for(int j = 1; j &lt;= n; ++j)
                read(w[i][j]);
        printf(&quot;%d\n&quot;, KM()), ret = 0;
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>[C++]图论-二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj3837 [Pa2013]Filary（随机化）</title>
    <url>/2019/01/10/35/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>权限题</p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这题有一个很好的性质，就是一定有$k&gt;\frac n2$。接着考虑怎么做。</p>
<p>我们随机选取一个数$x$，然后将所有数与它作差，那么只需要找出$k$个差值使得他们的最大公因数大于$1$即可。我们可以将所有差值分解质因数，然后统计每个质因数出现的次数，再加上与$x$相等的数的个数就是$k$。统计$k$个时候顺便记录一下这些数的最大公因数即可。</p>
<p>根据之前说的那个性质，我们随机出真答案的期望是$log$的。但是随机化这个东西…是靠脸的，我最开始用了那个$8$位质数做种子，然后调了$10$次，最后调了半天改成不用种子，随机$4$次。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
using std::__gcd;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 1e5 + 10, M = 1e7 + 10, _ = 1e6 + 10;
int n, x, nk, nm, k, m, tot;
int prime[_], save[M], s[_], g[_], v[N], c[N];
bool notprime[M];

int main () &#123;
    for(int i = 2; i &lt;= 10000000; ++i) &#123;
        if(!notprime[i]) prime[++tot] = i, save[i] = tot;
        for(int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= 10000000; ++j) &#123;
            notprime[i * prime[j]] = 1, save[i * prime[j]] = j;
            if(!(i % prime[j])) break;
        &#125;
    &#125; read(n);
    for(int i = 1; i &lt;= n; ++i) read(v[i]);
    for(int T = 1; T &lt;= 4; ++T) &#123;
        x = v[rand() % n + 1], nk = s[0] = 0;
        for(int i = 1; i &lt;= n; ++i) &#123;
            c[i] = abs(v[i] - x);
            if(!c[i]) ++s[0];
        &#125;
        for(int i = 1; i &lt;= n; ++i) &#123;
            int t = c[i];
            while(t &amp;&amp; t != 1) &#123;
                int tmp = save[t];
                ++s[tmp], g[tmp] = __gcd(g[tmp], c[i]);
                if(nk &lt; s[tmp] + s[0]) nk = s[tmp] + s[0], nm = 0;
                if(nk == s[tmp] + s[0]) nm = max(nm, g[tmp]);
                while(!(t % prime[tmp])) t /= prime[tmp];
            &#125;
        &#125;

        if(nk &gt; k) k = nk, m = 0;
        if(nk == k) m = max(m, nm);
        for(int i = 1; i &lt;= n; ++i) &#123;
            int t = c[i];
            while(t &amp;&amp; t != 1) &#123;
                int tmp = save[t];
                s[tmp] = g[tmp] = 0;
                while(!(t % prime[tmp])) t /= prime[tmp];
            &#125;
        &#125; 
    &#125;printf(&quot;%d %d\n&quot;, k, m);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]算法思想-随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj3566/洛谷P4284 [SHOI2014]概率充电器（概率dp）</title>
    <url>/2019/01/09/34/</url>
    <content><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=3566">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P4284">洛谷</a></p>
<span id="more"></span>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先考虑从儿子来的贡献：</p>
<script type="math/tex; mode=display">
f[u]=\prod_{v \in son[u]}f[v]+(1-f[v])\times(1-dis[i])</script><p>根据容斥原理，就是儿子直接亮的概率减去当儿子不亮且他们之间的路径均不直接亮时的概率</p>
<p>接着考虑从父亲来的贡献，设$p$为：$\frac{g[u]\times f[u]}{f[v]+(1-f[v])\times(1-dis[i])}$</p>
<p>则：（画画图就可以理解）</p>
<script type="math/tex; mode=display">
g[v]=p+(1-p)\times(1-dis[i])</script><p>最后答案就是</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n1-f[i]\times g[i]</script><pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;
typedef double db;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 5e5 + 10;
db poi[N], ret, son[N], fa[N], dis[N &lt;&lt; 1];
int n, to[N &lt;&lt; 1], nxt[N &lt;&lt; 1], from[N], cnt;
bool vis[N];
inline void addEdge(int u, int v, db w) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], dis[cnt] = w, from[u] = cnt;
&#125;

void dfs1(int u) &#123;
    vis[u] = 1, son[u] = 1. - poi[u];
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; if(vis[v]) continue; dfs1(v);
        son[u] *= son[v] + (1. - son[v]) * (1. - dis[i]);
    &#125; vis[u] = 0;
&#125;

void dfs2(int u) &#123;
    vis[u] = 1;
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; if(vis[v]) continue;
        db p = fa[u] * son[u] / (son[v] + (1. - son[v]) * (1. - dis[i]));
        fa[v] = p + (1. - p) * (1. - dis[i]); dfs2(v);
    &#125;
&#125;

int main () &#123;
    read(n);
    for(int i = 1, u, v, w; i &lt; n; ++i)
        read(u), read(v), read(w), addEdge(u, v, w / 100.), addEdge(v, u, w / 100.);
    for(int i = 1, p; i &lt;= n; ++i)
        read(p), poi[i] = p / 100.;
    fa[1] = 1, dfs1(1), dfs2(1);
    for(int i = 1; i &lt;= n; ++i)
        ret += 1. - fa[i] * son[i];
    return printf(&quot;%.6lf\n&quot;, ret) &amp; 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]动态规划-概率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>杜教筛学习笔记</title>
    <url>/2019/01/08/33/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里假设你已经会了以下东西：</p>
<ul>
<li>狄利克雷卷积</li>
<li>莫比乌斯反演</li>
<li>数论分块</li>
</ul>
<span id="more"></span>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一切的开始"><a href="#一切的开始" class="headerlink" title="一切的开始"></a>一切的开始</h3><p>先来看一个题目（Bzoj 4805）：</p>
<p>给你一个整数$n$，求以下东西：</p>
<p>求$\sum_{i=1}^n \varphi_i$</p>
<p>可以线性筛吧…但是如果$n\leq 2e9$呢？</p>
<h3 id="杜教筛是啥？"><a href="#杜教筛是啥？" class="headerlink" title="杜教筛是啥？"></a>杜教筛是啥？</h3><p>设$\mathbf S(n)=\sum_{i=1}^n\mathbf f(i)$，其中$\mathbf f$是积性函数。</p>
<p>我们不妨设一个$\mathbf g$，不管它具体是啥，做一个狄利克雷卷积：</p>
<script type="math/tex; mode=display">
(\mathbf g\ast \mathbf f)(i)=\sum_{d|i}\mathbf g(d)\mathbf f(\frac id)</script><p>然后再求一个和：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{d|i}\mathbf g(d)\mathbf f(\frac id)
\\=\sum_{d=1}^n\mathbf g(d)\sum_{d|i}\mathbf f(\frac id)
\\=\sum_{d=1}^n\mathbf g(d)\sum_{i=1}^{n/d}\mathbf f(i)
\\=\sum_{d=1}^n\mathbf g(d)\mathbf S(\frac nd)</script><p>然后还有：</p>
<script type="math/tex; mode=display">
\mathbf g(1)\mathbf S(n)=\sum_{i=1}^n\mathbf g(i)\mathbf S(\frac ni)-
\sum_{i=2}^n\mathbf g(i)\mathbf S(\frac ni)</script><p>前面减数就是我们之前推的那个东西，后面被减数可以数论分块递归算：</p>
<script type="math/tex; mode=display">
\mathbf g(1)\mathbf S(n)=\sum_{i=1}^n(\mathbf g\ast \mathbf f)(i)-
\sum_{i=2}^n\mathbf g(i)\mathbf S(\frac ni)</script><p>比如要求$\sum_{i=1}^n\mu(i)$</p>
<script type="math/tex; mode=display">
\mathbf g(1)\mathbf S(n)=\sum_{i=1}^n(\mathbf g\ast \mu)(i)-
\sum_{i=2}^n\mathbf g(i)\mathbf S(\frac ni)</script><p>找一个积性函数让他们的狄利克雷卷积很好算：</p>
<p>我们知道$\mu$的逆为$1$，也就是说$(1\astμ)=\epsilon$</p>
<p>那么单位元的前缀和是1，舒服啊，所以取$\mathbf g(n)$为$\mathbf 1(n)=1$，</p>
<p>所以原式可化为：</p>
<script type="math/tex; mode=display">
\mathbf S(n)=1-\sum_{i=2}^n\mathbf S(\frac ni)</script><h3 id="那么回归到例题"><a href="#那么回归到例题" class="headerlink" title="那么回归到例题"></a>那么回归到例题</h3><script type="math/tex; mode=display">
\mathbf S(n)=\sum_{i=1}^n \varphi_i
\\\mathbf g(1)\mathbf S(n)=\sum_{i=1}^n(\mathbf g\ast \varphi)(i)-
\sum_{i=2}^n\mathbf g(i)\mathbf S(\frac ni)</script><p>这时我们要找一个$\mathbf g$使得$\mathbf g$和$\mathbf g \ast \varphi$的前缀和都很好算</p>
<p>这时我们想到了$\varphi=\mu*\mathbf{id}$，</p>
<p>所以啊：$\varphi*\mathbf 1=\mathbf{id}$，则这里同样取$\mathbf g(n)$为$\mathbf 1(n)=1$</p>
<script type="math/tex; mode=display">
\\\mathbf S(n)=\frac{n\times (n+1)}{2}-
\sum_{i=2}^n\mathbf S(\frac ni)</script><p>所以，杜教筛的重点就在于选取一个有利于计算的$\mathbf g$…</p>
<p>下面给出这题的代码：</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

const int N = 2147483647, M = 2e6 + 10, K = 1.3e3 + 10;
ll phi[M], s1[M], s2[K]; bool vis[K], notprime[M];
int _n, prime[M], tot;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

ll S(int n) &#123;
    if(n &lt; M) return s1[n];
    int x = _n / n;
    if(vis[x]) return s2[x];
    vis[x] = true; ll &amp;ans = s2[x];
    ans = 1ll * n * (n + 1) / 2;
    for(int i = 2, j; i &lt;= n; i = j + 1)
        j = n / (n / i), ans -= (j - i + 1) * S(n / i);
    return ans;
&#125;

void get_phi() &#123;
    phi[1] = 1;
    for(int i = 2; i &lt; M; ++i) &#123;
        if(!notprime[i]) prime[++tot] = i, phi[i] = i - 1;
        for(int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt; M; ++j) &#123;
            notprime[i * prime[j]] = true;
            if(!(i % prime[j])) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125;
            else phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        &#125;
    &#125;
&#125;

int main () &#123;
    read(_n), get_phi();
    for(int i = 1; i &lt; M; ++i) s1[i] = s1[i - 1] + phi[i];
    printf(&quot;%lld\n&quot;, S(_n));
    return 0; 
&#125;
</code></pre>
<h3 id="一些例题："><a href="#一些例题：" class="headerlink" title="一些例题："></a>一些例题：</h3><ul>
<li>Bzoj3512 DZY Loves Math IV</li>
<li>LuoguP3768 简单的数学题</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>[C++]数论-杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>【Bzoj4555】【Luogu P4091】求和（NTT）</title>
    <url>/2018/12/30/32/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=4555">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P4091">Luogu</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先来颓柿子</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n\sum_{j=0}^iS(i,j)2^jj! \\ =\sum_{j=0}^n2^jj!\sum_{i=0}^nS(i,j) \\ \because S(n, m)=\frac1{m!}\sum_{i=0}^m(-1)^i\binom{m}{i}(m-i)^n=\sum_{i=0}^m\frac{(-1)^i}{i!}\frac{(m-i)^n}{(m-i)!} \\ \therefore=\sum_{j=0}^n2^jj!\sum_{i=0}^n\sum_{k=0}^{j}\frac{(-1)^k}{k!}\frac{(j-k)^i}{(j-k)!} \\ =\sum_{j=0}^n2^jj!\sum_{k=0}^j\frac{(-1)^k}{k!}\frac{\sum_{i=0}^n(j-k)^i}{(j-k)!} \\ =\sum_{j=0}^n2^jj!\sum_{k=0}^j\frac{(-1)^k}{k!}\frac{(j-k)^{n+1}-1}{(j-k-1)(j-k)!}</script><p>然后后面那一大坨可以看做卷积，因为要取模，$NTT$就好了。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using std::swap;

const int N = 2.7e5 + 10, Mod = 998244353, g = 3;
int n, m, P, jc[N], pow2[N], invjc[N];
int a[N], b[N], r[N], ret;

int qpow(int a, int b) &#123;
    int ret = 1;
    while(b) &#123;
        if(b &amp; 1) ret = 1ll * ret * a % Mod;
        a = 1ll * a * a % Mod, b &gt;&gt;= 1;
    &#125; return ret;
&#125;

void NTT (int f[], int opt) &#123;
    for(int i = 0; i &lt; n; ++i) if(i &lt; r[i]) swap(f[i], f[r[i]]);
    for(int len = 1, nl = 2; len &lt; n; len = nl, nl &lt;&lt;= 1) &#123;
        int rot = qpow(g, (Mod - 1) / nl);
        if(opt == -1) rot = qpow(rot, Mod - 2);
        for(int l = 0; l &lt; n; l += nl) &#123;
            int w = 1, r = l + len;
            for(int k = l; k &lt; r; ++k, w = 1ll * w * rot % Mod) &#123;
                int x = f[k], y = 1ll * f[k + len] * w % Mod;
                f[k] = (x + y) % Mod, f[k + len] = (x + Mod - y) % Mod;
            &#125;
        &#125;
    &#125;
&#125;

int main () &#123;
    scanf(&quot;%d&quot;, &amp;n), jc[0] = pow2[0] = invjc[0] = b[0] = 1, b[1] = n + 1;
    for(int i = 1; i &lt;= n; ++i)
        jc[i] = 1ll * jc[i - 1] * i % Mod, pow2[i] = (pow2[i - 1] &lt;&lt; 1) % Mod;
    invjc[n] = qpow(jc[n], Mod - 2);
    for(int i = n - 1; i; --i) invjc[i] = 1ll * invjc[i + 1] * (i + 1) % Mod;
    for(int i = 0; i &lt;= n; ++i) a[i] = 1ll * invjc[i] * (i &amp; 1 ? Mod - 1 : 1) % Mod;
    for(int i = 2; i &lt;= n; ++i)
        b[i] = 1ll * (qpow(i, n + 1) + Mod - 1) % Mod * qpow(i - 1, Mod - 2) % Mod * invjc[i] % Mod;
    for(m = n &lt;&lt; 1, n = 1; n &lt;= m; n &lt;&lt;= 1, ++P);
    for(int i = 0; i &lt; n; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (P - 1));
    NTT(a, 1), NTT(b, 1);
    for(int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * b[i] % Mod;
    NTT(a, -1); int invn = qpow(n, Mod - 2);
    for(int i = 0; i &lt;= n; ++i)
        ret = (ret + 1ll * pow2[i] * jc[i] % Mod * a[i] % Mod * invn % Mod) % Mod;
    printf(&quot;%d\n&quot;, ret);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数论-快速数论变换/NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>【Bzoj3527】【Luogu3338】[Zjoi2014]力（FFT）</title>
    <url>/2018/12/30/31/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=3527">Bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P3338">Luogu</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先来颓柿子</p>
<script type="math/tex; mode=display">
F_i=\sum_{j<i}\frac{q_iq_j}{(i-j)^2}-\sum_{j>i}\frac{q_iq_j}{(i-j)^2}
\\=q_i(\sum_{j<i}\frac{q_j}{(i-j)^2}-\sum_{j>i}\frac{q_j}{(i-j)^2})</script><p>所以</p>
<script type="math/tex; mode=display">
E_i=\sum_{j<i}\frac{q_j}{(i-j)^2}-\sum_{j>i}\frac{q_j}{(j-i)^2}</script><p>令$x_i=\frac{1}{i^2}$</p>
<p>则原式可化为：</p>
<script type="math/tex; mode=display">
E_i=\sum_{j=0}^{i}q_jx_{i-j}-\sum_{j=i+1}^{n-1}q_jx_{j-i}</script><p>令$p_{n-j-1}=q_j$所以原式又等于</p>
<script type="math/tex; mode=display">
E_i=\sum_{j=0}^{i}q_jx_{i-j}-\sum_{j=i}^{n-1}p_{n-j-1}x_{j-i}
\\=\sum_{j=0}^{i}q_jx_{i-j}-\sum_{j=0}^{n-i-1}p_{n-j-i-1}x_{j}</script><p>然后就变成两个卷积相减了吧。（为了方便，先将$n$减去$1$）：</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using std::swap;

const int N = 3e5 + 10;
const double Pi = acos(-1);
int n, m, r[N], P;
struct C &#123; double x, y; &#125; q[N], p[N], x[N];
C operator + (C a, C b) &#123; return (C)&#123; a.x + b.x, a.y + b.y &#125;; &#125;
C operator - (C a, C b) &#123; return (C)&#123; a.x - b.x, a.y - b.y &#125;; &#125;
C operator * (C a, C b) &#123; return (C)&#123; a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y &#125;; &#125;

void FFT(C f[], int opt) &#123;
    for(int i = 0; i &lt; n; ++i) if(i &lt; r[i]) swap(f[i], f[r[i]]);
    for(int len = 1, nl = 2; len &lt; n; len = nl, nl &lt;&lt;= 1) &#123;
        C rot = (C)&#123;cos(Pi / len), opt * sin(Pi / len)&#125;;
        for(int l = 0; l &lt; n; l += nl) &#123;
            C w = (C)&#123;1, 0&#125;; int r = l + len;
            for(int k = l; k &lt; r; ++k, w = w * rot) &#123;
                C x = f[k], y = w * f[k + len];
                f[k] = x + y, f[k + len] = x - y;
            &#125;
        &#125;
    &#125;
&#125; 

int main() &#123;
    scanf(&quot;%d&quot;, &amp;n); int tmp = (--n); m = n &lt;&lt; 1;
    for(int i = 0; i &lt;= n; ++i) scanf(&quot;%lf&quot;, &amp;q[i].x), p[n - i].x = q[i].x;
    for(int i = 1; i &lt;= n; ++i) x[i].x = (double)1.0 / i / i;
    for(n = 1; n &lt;= m; n &lt;&lt;= 1, ++P);
    for(int i = 0; i &lt; n; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (P - 1));
    FFT(q, 1), FFT(p, 1), FFT(x, 1);
    for(int i = 0; i &lt; n; ++i) q[i] = q[i] * x[i], p[i] = p[i] * x[i];
    FFT(q, -1), FFT(p, -1);
    for(int i = 0; i &lt;= tmp; ++i)
        printf(&quot;%.3lf\n&quot;, q[i].x / n - p[tmp - i].x / n);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数论-快速傅里叶变换/FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>FFT实现高精度乘法</title>
    <url>/2018/12/30/30/</url>
    <content><![CDATA[<p>你应该知道$FFT$是用来处理多项式乘法的吧。</p>
<p>那么高精度乘法和多项式乘法有什么关系呢？</p>
<span id="more"></span>
<p>观察这样一个$20$位高精度整数$11111111111111111111$</p>
<p>我们可以把它处理成这样的形式：$\sum_{i=0}^{19}1\times10^i$</p>
<p>这样就变成了一个多项式了！</p>
<p>直接上代码吧（以$Luogu\ P1919$为例）：</p>
<pre><code class="lang-cpp">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using std::swap;

const int N = 1.4e5 + 10;
const double Pi = acos(-1);
int n, m, r[N], P, ans[N];
char s[N];
struct C &#123; double x, y; &#125; a[N], b[N];
C operator + (C a, C b) &#123; return (C)&#123; a.x + b.x, a.y + b.y &#125;; &#125;
C operator - (C a, C b) &#123; return (C)&#123; a.x - b.x, a.y - b.y &#125;; &#125;
C operator * (C a, C b) &#123; return (C)&#123; a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y &#125;; &#125;

void FFT(C f[], int opt) &#123;
    for(int i = 0; i &lt; n; ++i) if(i &lt; r[i]) swap(f[i], f[r[i]]);
    for(int len = 1, nl = 2; len &lt; n; len = nl, nl &lt;&lt;= 1) &#123;
        C rot = (C)&#123;cos(Pi / len), opt * sin(Pi / len)&#125;;
        for(int l = 0; l &lt; n; l += nl) &#123;
            C w = (C)&#123;1, 0&#125;; int r = l + len;
            for(int k = l; k &lt; r; ++k, w = w * rot) &#123;
                C x = f[k], y = w * f[k + len];
                f[k] = x + y, f[k + len] = x - y;
            &#125;
        &#125;
    &#125;
&#125; 

int main() &#123;
    scanf(&quot;%d%s&quot;, &amp;n, s + 1);
    for(int i = 1; i &lt;= n; ++i) a[i - 1].x = s[n - i + 1] - &#39;0&#39;;
    scanf(&quot;%s&quot;, s + 1);
    for(int i = 1; i &lt;= n; ++i) b[i - 1].x = s[n - i + 1] - &#39;0&#39;;
    //将字符串转化为多项式的系数
    --n;
    for(m = n + n, n = 1; n &lt;= m; n &lt;&lt;= 1, ++P);
    for(int i = 0; i &lt; n; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (P - 1));
    //蝴蝶变换FFT
    FFT(a, 1), FFT(b, 1);
    for(int i = 0; i &lt; n; ++i) a[i] = a[i] * b[i];
    FFT(a, -1);
    for(int i = 0; i &lt;= m; ++i) ans[i] = (int)(a[i].x / n + .5);
    for(int i = 0, tmp1, tmp2; i &lt; m; ++i)
        ans[i + 1] += (ans[i] / 10), ans[i] %= 10;
    //处理进位（每个系数最多为两位数）
    for(int i = m, flag = 0; i &gt;= 0; --i) &#123;
        if(ans[i] != 0) flag = 1;
        else if(!flag) continue;
        printf(&quot;%d&quot;, ans[i]); 
    &#125;//flag为前导零标记
    return puts(&quot;&quot;) &amp; 0;
&#125;
</code></pre>
<p>$PS：$代码中没有处理$0\times0$的情况，请读者自行处理。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>[C++]数论-快速傅里叶变换/FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj 2190 仪仗队（莫比乌斯反演）</title>
    <url>/2018/12/28/29/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://lydsy.com/JudgeOnline/problem.php?id=2190">bzoj</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P2158">洛谷</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>看这个题先大力猜一波结论</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
using std::__gcd;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 4e4 + 10;
int n, ret;
bool a[N][N];

int main () &#123;
#ifdef OFFLINE_JUDGE
    freopen(&quot;233.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;233.out&quot;, &quot;w&quot;, stdout);
#endif
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 2; i &lt;= n; ++i)
        for(int j = 2; j &lt;= n; ++j) &#123;
            int tmp = __gcd(i, j);
            int tmpi = i / tmp, tmpj = j / tmp;
            if(!a[tmpi][tmpj]) ++ret, a[tmpi][tmpj] = true;
        &#125;
    printf(&quot;%d\n&quot;, ret + 2);        
    return 0;
&#125;
</code></pre>
<p>然后：</p>
<p><img src="https://www.cnblogs.com/images/cnblogs_com/water-mi/1371765/o_2018-12-27%2015-09-57%e5%b1%8f%e5%b9%95%e6%88%aa%e5%9b%be.png" alt="1.jpg"></p>
<p>很接近了，仔细一想，应该是：</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
using std::__gcd;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 4e4 + 10;
int n, ret;
bool a[N][N];

int main () &#123;
#ifdef OFFLINE_JUDGE
    freopen(&quot;233.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;233.out&quot;, &quot;w&quot;, stdout);
#endif
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 0; i &lt; n; ++i)
        for(int j = 0; j &lt; n; ++j) &#123;
            int tmp = __gcd(i, j);
            if(tmp == 1) ++ret/*, a[tmpi][tmpj] = true*/;
        &#125;
    printf(&quot;%d\n&quot;, ret);
    return 0;
&#125;
</code></pre>
<p>然后过了：</p>
<p><img src="https://www.cnblogs.com/images/cnblogs_com/water-mi/1371765/o_2018-12-27%2015-11-03%e5%b1%8f%e5%b9%95%e6%88%aa%e5%9b%be.png" alt="2.jpg"></p>
<p>那不就是$Bzoj1101\ Zap$了，直接蒯（注意特判一下$n==1$的情况）</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 4e4 + 10;
int t, n, mu[N], g[N], prime[N], cnt;
long long sum[N]; bool notprime[N];

void getmu(int k) &#123;
    mu[1] = 1;
    for(int i = 2; i &lt;= k; ++i) &#123;
        if(!notprime[i]) prime[++cnt] = i, mu[i] = -1;
        for(int j = 1; j &lt;= cnt &amp;&amp; prime[j] * i &lt;= k; ++j) &#123;
            notprime[prime[j] * i] = true;
            if(!(i % prime[j])) break;
            mu[prime[j] * i] = -mu[i];
        &#125;
    &#125;
    for(int i = 1; i &lt;= k; ++i)
        sum[i] = sum[i - 1] + 1ll * mu[i];
&#125;

int main () &#123;
#ifdef OFFLINE_JUDGE
    freopen(&quot;233.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;233.out&quot;, &quot;w&quot;, stdout);
#endif
    getmu(40000); 
    read(n); ll ans = n &gt; 1 ? 2 : 0; --n;
    for(int l = 1, r; l &lt;= n; l = r + 1) &#123;
        r = n / (n / l);
        ans += (sum[r] - sum[l - 1]) * (n / l) * (n / l);
    &#125;
    printf(&quot;%lld\n&quot;, ans);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数论-莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj1101 Zap（莫比乌斯反演）</title>
    <url>/2018/12/28/28/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://lydsy.com/JudgeOnline/problem.php?id=1101">题面</a></h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先化式子</p>
<script type="math/tex; mode=display">
\sum_{x=1}^a\sum_{y=1}^b\mathbf f[gcd(x,y)==d]
\\ = \sum_{x=1}^a\sum_{y=1}^b\sum_{d\mid x,d\mid y}\mathbf f[gcd(x,y)==1]
\\ = \sum_{x=1}^{\lfloor \frac ad\rfloor}\sum_{y=1}^{\lfloor \frac bd\rfloor}\mathbf f[gcd(x,y)==1]</script><p>然后套路就类似于$Bzoj2818\ Gcd$了，只不过直接$\mathbf f$的逆直接变成了$\mu$。（我直接在那题基础上改的）</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 5e4 + 10;
int t, n, m, d, mu[N], g[N], prime[N], cnt;
long long sum[N]; bool notprime[N];

void getmu(int k) &#123;
    mu[1] = 1;
    for(int i = 2; i &lt;= k; ++i) &#123;
        if(!notprime[i]) prime[++cnt] = i, mu[i] = -1;
        for(int j = 1; j &lt;= cnt &amp;&amp; prime[j] * i &lt;= k; ++j) &#123;
            notprime[prime[j] * i] = true;
            if(!(i % prime[j])) break;
            mu[prime[j] * i] = -mu[i];
        &#125;
    &#125;
    for(int i = 1; i &lt;= k; ++i)
        sum[i] = sum[i - 1] + 1ll * mu[i];
&#125;

int main () &#123;
    read(t); getmu(50000); 
    while(t--) &#123;
        read(n), read(m), read(d); ll ans = 0;
        n /= d, m /= d;
        if(n &gt; m) swap(n, m);
        for(int l = 1, r; l &lt;= n; l = r + 1) &#123;
            r = min(n / (n / l), m / (m / l));
            ans += (sum[r] - sum[l - 1]) * (m / l) * (n / l);
        &#125; printf(&quot;%lld\n&quot;, ans);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数论-莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj2818 Gcd（莫比乌斯反演）</title>
    <url>/2018/12/28/27/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://lydsy.com/JudgeOnline/problem.php?id=2818">题面</a></h2><p>题意都在题目里面了</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>你可以把题意看成这个东西</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^m\mathbf f(gcd(i,j))</script><p>其中$\mathbf f(n)$为<code>[n是否是一个质数]</code></p>
<p>然后把$\mathbf f$反演一下，找到一个$\mathbf g$令$\mathbf f=\mathbf 1 \ast \mathbf g$，即：</p>
<script type="math/tex; mode=display">
\mathbf g(n)=\sum_{d\mid n}\mu(\frac nd)\cdot \mathbf f(d)=\sum_{d\mid n, d \in prime}\mu (\frac nd)</script><p>所以$\mathbf g$可以这样求：</p>
<pre><code class="lang-cpp">for(int j = 1; j &lt;= cnt; ++j)
    for(int i = 1; i * prime[j] &lt;= n; ++i)
        g[i * prime[j]] += mu[i];
</code></pre>
<p>就是枚举系数。</p>
<p>接着考虑怎么做：</p>
<p>由于$gcd$有一个很好的性质：</p>
<p>$d\mid gcd(i,j) \Leftrightarrow d\mid i, d\mid j$</p>
<p>所以</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^n\sum_{d\mid i,d\mid j}\mathbf g(d)
\\ =\sum_{d=1}^{min(n,m)}\mathbf g(d)\sum_{i=1}^n\sum_{j=1}^m[d\mid i][d\mid j]
\\ =\sum_{d=1}^{min(n,m)}\mathbf g(d) \lfloor\frac nd \rfloor\lfloor\frac md\rfloor</script><p>然后就可以整除分块了！！</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 1e7 + 10;
int t, n, m, mu[N], g[N], prime[N], cnt;
long long sum[N], ans; bool notprime[N];

void getmu(int k) &#123;
    mu[1] = 1;
    for(int i = 2; i &lt;= k; ++i) &#123;
        if(!notprime[i]) prime[++cnt] = i, mu[i] = -1;
        for(int j = 1; j &lt;= cnt &amp;&amp; prime[j] * i &lt;= k; ++j) &#123;
            notprime[prime[j] * i] = true;
            if(!(i % prime[j])) break;
            mu[prime[j] * i] = -mu[i];
        &#125;
    &#125;
    for(int j = 1; j &lt;= cnt; ++j)
        for(int i = 1; i * prime[j] &lt;= k; ++i)
            g[i * prime[j]] += mu[i];
    for(int i = 1; i &lt;= k; ++i)
        sum[i] = sum[i - 1] + 1ll * g[i];
&#125;

int main () &#123;
    read(n), getmu(n);
    for(int l = 1, r; l &lt;= n; l = r + 1) &#123;
        r = n / (n / l);
        ans += (sum[r] - sum[l - 1]) * (n / l) * (n / l);
    &#125; printf(&quot;%lld\n&quot;, ans);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数论-莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演小结</title>
    <url>/2018/12/28/26/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="注意！！！！"><a href="#注意！！！！" class="headerlink" title="注意！！！！"></a>注意！！！！</h2><p>这里不是学习笔记，只是一些有关知识的总结！！</p>
<h2 id="狄利克雷卷积（符号：-ast-）"><a href="#狄利克雷卷积（符号：-ast-）" class="headerlink" title="狄利克雷卷积（符号：$\ast$）"></a>狄利克雷卷积（符号：$\ast$）</h2><p>如果$\mathbf t=\mathbf f \ast \mathbf g$</p>
<p>则：</p>
<script type="math/tex; mode=display">
\mathbf t(n)=\sum_{d|n}\mathbf f(d)g(\frac{n}{d})</script><p>狄利克雷卷积还有以下性质：</p>
<p>交换律，结合律，分配率，等等….</p>
<p>一个函数（$\mathbf f$）的逆（$\mathbf g$）：即$\mathbf f \ast \mathbf g= \epsilon$ 单位元$\epsilon(n)=[n==1]$ </p>
<script type="math/tex; mode=display">
\mathbf g(n)=\frac{1}{\mathbf f(1)}([n==1]-\sum_{d|n,d\neq1}\mathbf f(d)g(\frac{n}{d}))</script><h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><p>如果$\mathbf f(nm)=\mathbf f(n)\times \mathbf f(m) $ 则函数$\mathbf f$为完全积性函数。</p>
<p>如果再加上约束条件$n\perp m$，则函数为积性函数。一个完全积性函数一定是积性函数</p>
<p>积性函数的特殊性质：</p>
<ol>
<li>两个积性函数的狄利克雷卷积一定是积性函数</li>
<li>任意一个积性函数$\mathbf f(1)=1$恒成立</li>
<li>积性函数的逆一定是积性函数（可以在第二条性质的基础上证明）</li>
</ol>
<p>一些常见的积性函数有（定义$n=\prod_{i=1}^tp_i^{k_i}$，即唯一分解定理）</p>
<p>$\sigma<em>0(n)=\prod</em>{i=1}^t(k<em>i+1)$，$\varphi(n)=\prod</em>{i=1}^tp<em>i^{k_i-1}(p_i-1)=n\prod</em>{i=1}^t(1-\frac{1}{p_i})$</p>
<h2 id="莫比乌斯反演（摘自xgzc的博客）"><a href="#莫比乌斯反演（摘自xgzc的博客）" class="headerlink" title="莫比乌斯反演（摘自xgzc的博客）"></a>莫比乌斯反演（摘自xgzc的博客）</h2><p>定义一个函数$\mu$使得$\mu∗1=ϵ$，即$\mu$为$\mathbf 1(n)=\mathbf i\mathbf d^0(n)=1$的逆</p>
<p>这样的话，如果$\mathbf g∗\mathbf 1=\mathbf f$，则$\mathbf f∗\mu =\mathbf g$</p>
<p>即：如果$\mathbf f(n)=∑<em>{d|n}\mathbf g(d)$，则$\mathbf g(n)=∑</em>{d|n}\mu(d)\mathbf f(\frac nd)$</p>
<p><del>好难啊</del></p>
<h2 id="其他：整除分块"><a href="#其他：整除分块" class="headerlink" title="其他：整除分块"></a>其他：整除分块</h2><p>如果要你求一个东西：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \lfloor\frac ni \rfloor</script><p>你可能会说，这当然是$O(n)$求啊！！！</p>
<p>那么$n\leq 10^{14}$呢？？</p>
<p>你可能会说，我打了个表，发现在一段连续的区间内，函数值相同。但好像没有什么关系？？</p>
<p>不，根据前人的经验，每一个连续的区间，它的右界在$n/(n/i)$，所以，我们就可以在$O(\sqrt n)$算了。</p>
<p>比如说：</p>
<pre><code class="lang-cpp">for(int l = 1; l &lt;= n; l = r + 1) &#123;
    r = n / (n / l);
    ans += (r - l + 1) * (n / l);
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>[C++]数论-莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P4148 简单题（K-D Tree)</title>
    <url>/2018/12/25/25/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P4148">题面</a></h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为强制在线，所以我们不能$cdq$分治，所以考虑用$KDT$，$KDT$维护一个矩阵，然后询问的时候如果当前矩形在询问区间内，直接记贡献，否则判断当前点是否在矩阵内，然后左右分别递归下去判断就行了。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::nth_element;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 200005;
int n, x1, x2, y1, y2, k, ans, rt, WD, top, cnt, rub[N];
struct poi &#123; int x[2], w; &#125; p[N];
struct node &#123; int mi[2], mx[2], sum, lc, rc, siz; poi tp; &#125; t[N];
int operator &lt; (const poi &amp;a, const poi &amp;b) &#123; return a.x[WD] &lt; b.x[WD]; &#125;
inline int newnode() &#123; if(top) return rub[top--]; else return ++cnt; &#125;
void up(int k) &#123;
    int l = t[k].lc, r = t[k].rc;
    for(int i = 0; i &lt; 2; ++i) &#123;
        t[k].mi[i] = t[k].mx[i] = t[k].tp.x[i];
        if(l) t[k].mi[i] = min(t[k].mi[i], t[l].mi[i]), t[k].mx[i] = max(t[k].mx[i], t[l].mx[i]);
        if(r) t[k].mi[i] = min(t[k].mi[i], t[r].mi[i]), t[k].mx[i] = max(t[k].mx[i], t[r].mx[i]);
    &#125;
    t[k].sum = t[l].sum + t[r].sum + t[k].tp.w, t[k].siz = t[l].siz + t[r].siz + 1;
&#125;
int build(int l, int r, int wd) &#123;
    if(l &gt; r) return 0;
    int mid = (l + r) &gt;&gt; 1, k = newnode();
    WD = wd, nth_element(p + l, p + mid, p + r + 1), t[k].tp = p[mid];
    t[k].lc = build(l, mid - 1, wd ^ 1), t[k].rc = build(mid + 1, r, wd ^ 1);
    up(k); return k;
&#125;
void pia(int k, int num) &#123;
    if(t[k].lc) pia(t[k].lc, num);
    p[t[t[k].lc].siz + num + 1] = t[k].tp, rub[++top] = k;
    if(t[k].rc) pia(t[k].rc, num + t[t[k].lc].siz + 1);
&#125;
void check(int &amp;k, int wd) &#123;
    if(0.75 * t[k].siz &lt; t[t[k].lc].siz || 0.75 * t[k].siz &lt; t[t[k].rc].siz)
        pia(k, 0), k = build(1, t[k].siz, wd);
&#125;
void insert(int &amp;k, poi tmp, int wd) &#123;
    if(!k) &#123; k = newnode(), t[k].lc = t[k].rc = 0, t[k].tp = tmp, up(k); return ; &#125;
    if(tmp.x[wd] &lt;= t[k].tp.x[wd]) insert(t[k].lc, tmp, wd ^ 1);
    else insert(t[k].rc, tmp, wd ^ 1);
    up(k), check(k, wd);
&#125;
int in(int x1,int y1,int x2,int y2,int X1,int Y1,int X2,int Y2) &#123; return (X1&gt;=x1&amp;&amp;X2&lt;=x2&amp;&amp;Y1&gt;=y1&amp;&amp;Y2&lt;=y2); &#125;
int out(int x1,int y1,int x2,int y2,int X1,int Y1,int X2,int Y2) &#123; return (x1&gt;X2||x2&lt;X1||y1&gt;Y2||y2&lt;Y1); &#125;
int query(int k, int x1, int y1, int x2 ,int y2) &#123;
    if(!k) return 0;
    int ret = 0;
    if(in(x1, y1, x2, y2, t[k].mi[0], t[k].mi[1], t[k].mx[0], t[k].mx[1])) return t[k].sum;
    if(out(x1, y1, x2, y2, t[k].mi[0], t[k].mi[1], t[k].mx[0], t[k].mx[1])) return 0;
    if(in(x1, y1, x2, y2, t[k].tp.x[0], t[k].tp.x[1], t[k].tp.x[0], t[k].tp.x[1])) ret += t[k].tp.w;
    return ret + query(t[k].lc, x1, y1, x2, y2) + query(t[k].rc, x1, y1, x2, y2);
&#125;

int main () &#123;
    read(n);
    while(true) &#123;
        int opt; read(opt);
        if(opt == 3) break;
        else &#123;
            read(x1), read(y1), x1 ^= ans, y1 ^= ans;
            if(opt == 1) read(k), insert(rt, (poi)&#123;x1, y1, k ^ ans&#125;, 0);
            else &#123;
                read(x2), read(y2), x2 ^= ans, y2 ^= ans;
                ans = query(rt, x1, y1, x2, y2), printf(&quot;%d\n&quot;, ans);
            &#125;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-K-D Tree/KDT</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj 4524 [Cqoi2016]伪光滑数（堆）</title>
    <url>/2018/12/24/24/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://lydsy.com/JudgeOnline/problem.php?id=4524">题面</a></h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先筛出$&lt;128$的质数，很少，打个表即可</p>
<p>然后钦定一个质数最大，不断替换即可（丢进大根堆里面，然后取出一个，替换在丢进去即可）</p>
<p>具体来说，设一个四元组$[t,x,y,z]$表示当前的总乘积为$t$，$x$为最大的质数，$y$表示为$x$的多少次方，最后一个$z$表示当前能枚举的右界。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
using std::priority_queue;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

ll N;
int K, p[] = &#123;1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,
              61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127&#125;;
struct Node &#123; ll t; int x, y, z; &#125;;
bool operator &lt; (const Node &amp;a, const Node &amp;b) &#123; return a.t &lt; b.t; &#125;
priority_queue&lt;Node&gt; q;

int main () &#123;
    read(N), read(K);
    for(int i=1;i&lt;=31;i++) &#123;
        ll tmp = p[i];
        for(int j = 1; tmp &lt;= N; ++j, tmp *= p[i]) 
            q.push((Node)&#123;tmp, p[i], j, i - 1&#125;); 
    &#125;
    while(K--) &#123;
        Node now = q.top(); q.pop();
        if(!K) printf(&quot;%lld\n&quot;, now.t);
        else if(now.y &gt; 1)
            for(int i = 1; i &lt;= now.z; ++i)
                q.push((Node)&#123;now.t / now.x * p[i], now.x, now.y - 1, i&#125;);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-堆/优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj 2286 &amp; Luogu P2495 消耗战（LCA+虚树+欧拉序）</title>
    <url>/2018/12/24/23/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://www.luogu.org/problemnew/show/P2495">洛谷</a></p>
<p><a href="https://lydsy.com/JudgeOnline/problem.php?id=2286">Bzoj</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>很容易想到$O(nk)$的树形$dp$吧，设$f[i]$表示处理完这$i$颗子树的最小花费，同时再设一个$mi[i]$表示$i$到根节点$1$路径上的距离最小值。于是有：</p>
<script type="math/tex; mode=display">
f[i]=\sum min(f[son[i]], mi[son[i]])</script><p>这样就有$40$分了。</p>
<p>考虑优化：这里可以用虚树来优化，先把所有点按照$DFS$序进行排序，然后将相邻两个点的$LCA$以及$1$号点加入进$LCA$，然后虚树就构好了，考虑欧拉序的特殊性质，所以再还原出欧拉序，在上面做$dp$就好了。（xgzc告诉我可以再$dfs$一遍，但我不想写了，欧拉序多好啊）</p>
<pre><code class="lang-cpp">#include &lt;set&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::swap; using std::sort;
typedef long long ll;
using std::set;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar();
    x *= flag;
&#125;

const int N = 2.5e5 + 10, Inf = 1e9 + 7;
int n, m, dfin[N], dfout[N], tim;
int cnt, from[N], to[N &lt;&lt; 1], nxt[N &lt;&lt; 1];
int siz[N], son[N], dep[N], top[N], fa[N];
int nt[N &lt;&lt; 1], vis[N], s[N &lt;&lt; 1], tt;
ll mi[N], f[N], dis[N &lt;&lt; 1];
inline void addEdge(int u, int v, ll w) &#123;
    to[++cnt] = v, dis[cnt] = w, nxt[cnt] = from[u], from[u] = cnt;
&#125;
inline bool cmp(const int &amp;x, const int &amp;y) &#123;
    int k1 = x &gt; 0 ? dfin[x] : dfout[-x], k2 = y &gt; 0 ? dfin[y] : dfout[-y];
    return k1 &lt; k2;
&#125;

void dfs(int u) &#123;
    siz[u] = 1, dfin[u] = ++tim, dep[u] = dep[fa[u]] + 1;
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; if(v == fa[u]) continue;
        mi[v] = min(mi[u], dis[i]);
        fa[v] = u, dfs(v), siz[u] += siz[v];
        if(siz[v] &gt; siz[son[u]]) son[u] = v;
    &#125; dfout[u] = ++tim;
&#125;
void dfs(int u, int t) &#123;
    top[u] = t; if(!son[u]) return ;
    dfs(son[u], t);
    for(int i = from[u]; i; i = nxt[i])
        if(to[i] != son[u] &amp;&amp; to[i] != fa[u]) dfs(to[i], to[i]);
&#125;
int lca(int x, int y) &#123;
    int fx = top[x], fy = top[y];
    while(fx != fy)
        if(dep[fx] &gt; dep[fy]) x = fa[fx], fx = top[x];
        else y = fa[fy], fy = top[y];
    return dep[x] &lt; dep[y] ? x : y;
&#125;

int main () &#123;
    read(n);
    for(int i = 1; i &lt; n; ++i) &#123;
        int u, v; ll w; read(u), read(v), read(w);
        addEdge(u, v, w), addEdge(v, u, w);
    &#125;
    mi[1] = Inf, dfs(1), dfs(1, 1), read(m);
    for(int i = 1; i &lt;= m; ++i) &#123;
        int tot; read(tot);
        for(int j = 1; j &lt;= tot; ++j)
            read(nt[j]), vis[nt[j]] = true, f[nt[j]] = mi[nt[j]];
        sort(&amp;nt[1], &amp;nt[tot + 1], cmp);
        for(int j = 1; j &lt; tot; ++j) &#123;
            int cf = lca(nt[j], nt[j + 1]);
            if(!vis[cf]) nt[++tot] = cf, vis[cf] = true;
        &#125;
        int tmp = tot;
        for(int j = 1; j &lt;= tmp; ++j)
            nt[++tot] = -nt[j];
        if(!vis[1]) nt[++tot] = 1, nt[++tot] = -1;
        sort(&amp;nt[1], &amp;nt[tot + 1], cmp);
        for(int j = 1; j &lt;= tot; ++j)
            if(nt[j] &gt; 0) s[++tt] = nt[j];
            else &#123;
                int now = s[tt--];
                if(now != 1) &#123; int fat = s[tt]; f[fat] += min(f[now], mi[now]); &#125;
                else printf(&quot;%lld\n&quot;, f[1]);
                f[now] = vis[now] = 0;
            &#125;
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]树论-LCA,最近公共祖先</tag>
        <tag>[C++]树论-虚树</tag>
        <tag>[C++]树论-欧拉序</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 809D Hitchhiking in the Baltic States（FHQ-Treap）</title>
    <url>/2018/12/24/22/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你长度为$n$的序列，序列中的每个元素$i$有一个区间限制$[l_i,r_i]$，你从中选出一个子序列，并给它们标号$x_i$，要求满足 $∀i&lt;j，x_i&lt;x_j$，且$ ∀i，x_i∈[l_i,r_i]$。 问满足条件子序列的长度最长为多少？ </p>
<p>其中$1\leq n\leq3\times 10^5\ 1\leq l_i\leq r_i\leq 10^9$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>不妨设$f[i][j]$表示已经选到第$i$个，其中最大值为$j$最多能选几个。</p>
<p>显然是开不下的…但是还记得$O(nlogn)$的$LIS$吗？它利用了二分栈！</p>
<p>所以我们不妨考虑设$f[i][j]$表示当前选到第$i$个，已经选了$j$个的末尾最小元素。</p>
<p>如果不选，显然$f[i+1][j]=f[i][j]$</p>
<p>如果$r[i+1]&gt;f[i][j]$，那么，则有$f[i+1][j+1]=max(f[i][j]+1,l[i+1])$</p>
<p>不难发现可以用滚动数组滚掉第一维，所以第一个方程直接作废：</p>
<script type="math/tex; mode=display">
f[j+1]=max(f[j]+1,l[i+1])</script><p>但是时间还是$O(n^2)$的啊，枚举一个$i$，枚举一个$j$。</p>
<p>不急，咱们分开考虑，对于一个$l[i]&lt;f&lt;r[i]$</p>
<p>它的当前$dp$值可以直接$+1$，那么位置也将$+1$因为多选了一个嘛。</p>
<p>剩下的话，就是$f&lt;l[i]$的情况，直接就等于$l[i]$了。</p>
<p>用一颗$FHQ-Treap$维护一下就行了。</p>
<pre><code class="lang-cpp">#include &lt;ctime&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 3e5 + 10, Inf = 1e9 + 7;
int n, l, r;
int rt, tot, val[N], add[N], lc[N], rc[N], siz[N], pri[N];

inline int node(int x) &#123; val[++tot] = x, siz[tot] = 1, pri[tot] = rand(); return tot; &#125;
inline void pushdown(int o) &#123;
    if(add[o]) &#123;
        val[o] += add[o];
        if(lc[o]) add[lc[o]] += add[o];
        if(rc[o]) add[rc[o]] += add[o];
        add[o] = 0;
    &#125;
&#125;
int merge(int l, int r) &#123;
    if(!l || !r) return l + r;
    pushdown(l), pushdown(r);
    if(pri[l] &gt; pri[r]) &#123; rc[l] = merge(rc[l], r); return l; &#125;
    else &#123; lc[r] = merge(l, lc[r]); return r; &#125;
&#125;
void split(int o, int k, int &amp;l, int &amp;r) &#123;
    if(!o) &#123; l = r = 0; return ; &#125; pushdown(o);
    if(val[o] &lt;= k) l = o, split(rc[o], k, rc[o], r);
    else r = o, split(lc[o], k, l, lc[o]);
&#125;
int min(int o) &#123; pushdown(o); return lc[o] ? min(lc[o]) : val[o]; &#125;
int calc(int o) &#123;
    if(!o) return 0; pushdown(o);
    return calc(lc[o]) + calc(rc[o]) + (val[o] &lt; Inf);
&#125;

int main () &#123;
    read(n), srand(19260817); int x, y, k, p;
    for(int i = 1; i &lt;= n; ++i) rt = merge(rt, node(i + Inf));
    for(int i = 1; i &lt;= n; ++i) &#123;
        read(l), read(r);
        split(rt, l, x, k), split(k, r, k, y);
        if(k) add[k] += 1;
        split(y, min(y) + 1, p, y);
        rt = merge(merge(merge(x, node(l)), k), y);
    &#125; printf(&quot;%d\n&quot;, calc(rt));
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj 1014&amp;Luogu 4036 火星人Prefix（FHQ-Treap）</title>
    <url>/2018/12/24/21/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="https://www.luogu.org/problemnew/show/P4036">洛谷</a></p>
<p><a href="https://cn.vjudge.net/problem/HYSBZ-1014">Bzoj</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先，这种带修改的是不能用$SA$的，然后，我们做$SA$的题一般也能二分+$Hash$，所以不妨考虑用$FHQ-Treap$维护树，然后查询就用二分+$Hash$。</p>
<p>$Hash$怎么写？</p>
<script type="math/tex; mode=display">
hash[o]=hash[lc[o]]\times base[siz[rc[o]]+1]+val[o]\times base[siz[rc[o]]]+hash[rc[o]]</script><p>为什么可以这么写呢？<del>想一想，为什么</del></p>
<p>我们一般怎么求一颗维护序列的平衡树的原序列呢？—中序遍历</p>
<p>所以嘛，一棵子树的哈希值可以转化成它左子树的哈希值+本身的值+右子树哈希值</p>
<p>由于怕重复，所以可以考虑将前面两个值随便乘上一点什么东西（比如左子树或者右子树的$size$之类的）</p>
<pre><code class="lang-cpp">#include &lt;ctime&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 3e5 + 10;
char s[N];
int m, len, base[N];
int rt, tot, lc[N], rc[N], pri[N], siz[N], h[N], val[N];

inline void upt(int o) &#123;
    siz[o] = siz[lc[o]] + siz[rc[o]] + 1;
    h[o] = h[lc[o]] * base[siz[rc[o]] + 1] + val[o] * base[siz[rc[o]]] + h[rc[o]];
&#125;
inline int node(int x) &#123; siz[++tot] = 1, val[tot] = h[tot] = x, pri[tot] = rand(); return tot; &#125;
void split(int o, int k, int &amp;l, int &amp;r) &#123;
    if(!o) &#123; l = r = 0; return ; &#125;
    if(siz[lc[o]] &lt; k) l = o, split(rc[o], k - siz[lc[o]] - 1, rc[o], r);
    else r = o, split(lc[o], k, l, lc[o]);
    upt(o);
&#125;
int merge(int l, int r) &#123;
    if(!l || !r) return l + r;
    if(pri[l] &lt; pri[r]) &#123; rc[l] = merge(rc[l], r), upt(l); return l; &#125;
    else &#123; lc[r] = merge(l, lc[r]), upt(r); return r; &#125;
&#125;
inline int query(int l, int r) &#123;
    int x, y, k, ret;
    split(rt, r, x, y), split(x, l - 1, x, k);
    ret = h[k], rt = merge(merge(x, k), y);
    return ret;
&#125;

int main () &#123;
    scanf(&quot;%s&quot;, s + 1), len = strlen(s + 1), srand(19260817), base[0] = 1;
    for(int i = 1; i &lt; N; ++i) base[i] = base[i - 1] * 27;
    for(int i = 1; i &lt;= len; ++i) rt = merge(rt, node(s[i] - &#39;a&#39; + 1));
    read(m); char opt[5], ch[5]; int x, y, l, r, k;
    while(m--) &#123;
        scanf(&quot;%s&quot;, opt), read(x);
        if(opt[0] == &#39;Q&#39;) &#123;
            read(y); int L = 0, R = std::min(len - x, len - y) + 1, ret;
            while(L &lt;= R) &#123;
                int mid = (L + R) &gt;&gt; 1;
                if(query(x, x + mid - 1) == query(y, y + mid - 1)) ret = mid, L = mid + 1;
                else R = mid - 1;
            &#125; printf(&quot;%d\n&quot;, ret);
        &#125; else &#123;
            scanf(&quot;%s&quot;, ch), split(rt, x, l, r), ++len;
            if(opt[0] == &#39;R&#39;) --len, split(l, x - 1, l, k);
            rt = merge(merge(l, node(ch[0] - &#39;a&#39; + 1)), r);
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>Poj3580 Super Memo（FHQ Treap）</title>
    <url>/2018/12/24/20/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="http://poj.org/problem?id=3580">题面</a></h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对于操作$1$，我们可以对于每个节点打一个$add$标记，下放就行了</p>
<p>对于操作2，可以参考这篇题解的上一篇，不赘述</p>
<p>对于操作4，可以将区间裂成两部分，然后再插入合并</p>
<p>对于操作5，可以将区间裂成三部分，删除其中一个部分，合并其他两部分</p>
<p>对于操作6，打一个$min$标记，具体可以看代码。</p>
<hr>
<p>对于操作3，这个有点复杂，但是手玩可以发现，修改完后只是某两个断开的区间换了位置，只是断点不确定，算一下即可（细节有点多。）</p>
<hr>
<pre><code class="lang-cpp">#include &lt;ctime&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 2e5 + 10;
int n, m, lc[N], rc[N], siz[N], val[N], pri[N], rev[N], add[N], mn[N], tot;

inline void rotate(int o) &#123; std::swap(lc[o], rc[o]), rev[o] ^= 1; &#125;
inline void __add(int o, int v) &#123; val[o] += v, mn[o] += v, add[o] += v; &#125;
inline void upt(int o) &#123;
    siz[o] = siz[lc[o]] + siz[rc[o]] + 1, mn[o] = val[o];
    if(lc[o]) mn[o] = std::min(mn[o], mn[lc[o]]);
    if(rc[o]) mn[o] = std::min(mn[o], mn[rc[o]]);
&#125;
inline int node(int x) &#123;
    val[++tot] = x, pri[tot] = rand(), siz[tot] = 1, mn[tot] = x;
    return tot;
&#125;
void pushdown(int o) &#123;
    if(add[o]) &#123;
        if(lc[o]) __add(lc[o], add[o]);
        if(rc[o]) __add(rc[o], add[o]);
        add[o] = 0;
    &#125;
    if(rev[o]) &#123;
        if(lc[o]) rotate(lc[o]);
        if(rc[o]) rotate(rc[o]);
        rev[o] = 0;
    &#125;
&#125;
void split(int o, int k, int &amp;l, int &amp;r) &#123;
    if(!o) &#123; l = r = 0; return ; &#125; pushdown(o);
    if(siz[lc[o]] &lt; k) l = o, split(rc[o], k - siz[lc[o]] - 1, rc[o], r);
    else r = o, split(lc[o], k, l, lc[o]);
    upt(o);
&#125;
int merge(int l, int r) &#123;
    if(!l || !r) return l + r;
    pushdown(l), pushdown(r);
    if(pri[l] &lt; pri[r]) &#123; rc[l] = merge(rc[l], r), upt(l); return l; &#125;
    else &#123; lc[r] = merge(l, lc[r]), upt(r); return r; &#125;
&#125;

int main () &#123;
    read(n), srand(19260817);
    int x, y, l, r, k, rt = 0, D, T;
    for(int i = 1; i &lt;= n; ++i)
        read(x), rt = merge(rt, node(x));
    read(m); char opt[10];
    for(int i = 1; i &lt;= m; ++i) &#123;
        scanf(&quot;%s&quot;, opt), read(x);
        if(opt[0] == &#39;A&#39;) &#123;
            read(y), read(D);
            split(rt, y, l, r), split(l, x - 1, l, k);
            __add(k, D), rt = merge(merge(l, k), r);
        &#125;
        if(opt[0] == &#39;R&#39; &amp;&amp; opt[3] == &#39;E&#39;) &#123;
            read(y), split(rt, y, l, r), split(l, x - 1, l, k);
            rotate(k), rt = merge(merge(l, k), r); 
        &#125;
        if(opt[0] == &#39;R&#39; &amp;&amp; opt[3] == &#39;O&#39;) &#123;
            read(y), read(T);
            T %= (y - x + 1);
            if(!T) continue;
            T = (y - x + 1) - T;
            split(rt, y, l, r), split(l, x - 1, l, k);
            split(k, T, k, D);
            rt = merge(merge(l, merge(D, k)), r);
        &#125;
        if(opt[0] == &#39;I&#39;) read(y), split(rt, x, l, r), rt = merge(merge(l, node(y)), r);
        if(opt[0] == &#39;D&#39;) split(rt, x, l, r), split(l, x - 1, l, k), rt = merge(l, r);
        if(opt[0] == &#39;M&#39;) &#123;
            read(y), split(rt, y, l, r), split(l, x - 1, l, k);
            printf(&quot;%d\n&quot;,mn[k]), rt = merge(merge(l, k), r);
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P3391 【模板】文艺平衡树（FHQ-Treap）</title>
    <url>/2018/12/24/19/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个长为$n$序列$[1,2,…,n]$，$m$次操作，每次指定一段区间$[l,r]$，将这段区间翻转，求最终序列</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>虽然标题是$Splay$，但是我要用$FHQ\ Treap$，考虑先将$[l,r]$这段区间$split$出来（$k$即为这段区间）</p>
<pre><code class="lang-cpp">void split(int o, int k, int &amp;l, int &amp;r) &#123;
    if(!o) &#123; l = r = 0; return ; &#125;
    if(siz[lc[o]] &lt; k) l = o, split(rc[o], k - siz[lc[o]] - 1, rc[o], r);
    else r = o, split(lc[o], k, l, lc[o]);
    upt(o);
&#125;//注意这里要按size来split

//写在main函数中
while(m--) &#123;
    read(x), read(y);
    split(rt, y, l, r), split(l, x - 1, l, k);
    rev[k] ^= 1; rt = merge(merge(l, k), r);
&#125;//x,y为操作的区间
</code></pre>
<p>然后再将这段区间打一个翻转标记（因为平衡树是可以中序遍历输出的吧…，$rev$为翻转标记）</p>
<p>每次涉及到某个节点时，将$rev$标记下放就好了</p>
<pre><code class="lang-cpp">void pushdown(int o) &#123;
    std::swap(lc[o], rc[o]);
    if(lc[o]) rev[lc[o]] ^= 1;
    if(rc[o]) rev[rc[o]] ^= 1;
    rev[o] = 0;
&#125;
</code></pre>
<hr>
<pre><code class="lang-cpp">#include &lt;ctime&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int N = 1e5 + 10;
int n, m, lc[N], rc[N], siz[N], val[N], pri[N], rev[N], tot;

inline void upt(int o) &#123; siz[o] = siz[lc[o]] + siz[rc[o]] + 1; &#125;
inline int node(int x) &#123; val[++tot] = x, pri[tot] = rand(), siz[tot] = 1; return tot;&#125;
void pushdown(int o) &#123;
    std::swap(lc[o], rc[o]);
    if(lc[o]) rev[lc[o]] ^= 1;
    if(rc[o]) rev[rc[o]] ^= 1;
    rev[o] = 0;
&#125;
void split(int o, int k, int &amp;l, int &amp;r) &#123;
    if(!o) &#123; l = r = 0; return ; &#125;
    if(rev[o]) pushdown(o);
    if(siz[lc[o]] &lt; k) l = o, split(rc[o], k - siz[lc[o]] - 1, rc[o], r);
    else r = o, split(lc[o], k, l, lc[o]);
    upt(o);
&#125;
int merge(int l, int r) &#123;
    if(!l || !r) return l + r;
    if(pri[l] &lt; pri[r]) &#123; if(rev[l]) pushdown(l); rc[l] = merge(rc[l], r), upt(l); return l; &#125;
    else &#123; if(rev[r]) pushdown(r); lc[r] = merge(l, lc[r]), upt(r); return r; &#125;
&#125;
void print(int o) &#123;
    if(!o) return ;
    if(rev[o]) pushdown(o);
    print(lc[o]), printf(&quot;%d &quot;, val[o]), print(rc[o]);
&#125;

int main () &#123;
    read(n), read(m), srand((unsigned)time(NULL));
    int x, y, l, r, k, rt = 0;
    for(int i = 1; i &lt;= n; ++i) rt = merge(rt, node(i));
    while(m--) &#123;
        read(x), read(y);
        split(rt, y, l, r), split(l, x - 1, l, k);
        rev[k] ^= 1; rt = merge(merge(l, k), r);
    &#125; print(rt);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj 1055 玩具取名（区间DP）</title>
    <url>/2018/12/24/18/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<p>字符很麻烦，不妨用数字代替（比如1代表’W’）</p>
<pre><code class="lang-cpp">const char c[5] = &#123;0, &#39;W&#39;, &#39;I&#39;, &#39;N&#39;, &#39;G&#39;&#125;;
</code></pre>
<p>接着，像这种两个子串可以合并成另一个子串的题可以考虑区间$DP$</p>
<p>设$bool$数组$f_{i,j,k}$表示区间$[l,r]$能否合成单个字符$c_k$</p>
<p>于是就可以套区间$DP$的板子了</p>
<pre><code class="lang-cpp">#include &lt;map&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min; using std::max;
using std::sort; using std::swap;
using std::unique; using std::lower_bound;
using std::map;
typedef long long ll;

template&lt;typename T&gt;
void read(T &amp;x) &#123;
    int flag = 1; x = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) flag = -flag; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar(); x *= flag;
&#125;

const int Len = 2e2 + 10, _ = 5;
const char c[5] = &#123;0, &#39;W&#39;, &#39;I&#39;, &#39;N&#39;, &#39;G&#39;&#125;;
char s[Len]; bool p, f[Len][Len][_];
int num[_], list[Len][_], tot, len;
int check(char x) &#123; for(int i = 1; i &lt;= 4; ++i) if(x == c[i]) return i; &#125;

int main () &#123;
    for(int i = 1; i &lt;= 4; ++i) read(num[i]);
    for(int i = 1; i &lt;= 4; ++i)
        for(int j = 1; j &lt;= num[i]; ++j) &#123;
            char ss[5]; scanf(&quot;%s&quot;, ss);
            list[++tot][0] = i;
            list[tot][1] = check(ss[0]);
            list[tot][2] = check(ss[1]);
        &#125;
    scanf(&quot;%s&quot;, s + 1), len = strlen(s + 1);
    for(int i = 1; i &lt;= len; ++i) f[i][i][check(s[i])] = true;
    for(int k = 1; k &lt;= len; ++k)
        for(int i = 1; i + k &lt;= len; ++i) &#123;
            int j = i + k;
            for(int p = i; p &lt; j; ++p)
                for(int l = 1; l &lt;= tot; ++l)
                    if(f[i][p][list[l][1]] &amp;&amp; f[p + 1][j][list[l][2]])
                        f[i][j][list[l][0]] = true;
        &#125;
    for(int i = 1; i &lt;= 4; ++i)
        if(f[1][len][i]) putchar(c[i]), p = true;
    if(!p) printf(&quot;The name is wrong!&quot;);
    puts(&quot;&quot;);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]动态规划-区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Bzoj 3498 Cakes（三元环）</title>
    <url>/2018/12/24/17/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题面（权限题就不放题面了）"><a href="#题面（权限题就不放题面了）" class="headerlink" title="题面（权限题就不放题面了）"></a>题面（权限题就不放题面了）</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>三元环模板题，按题意模拟即可。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
using std::vector;

const int N = 1e5 + 10, M = 2.5e5 + 10;
int n, m, a[N], deg[N], u[M], v[M], vis[N], tmp;
long long ans;
vector&lt;int&gt; to[N];
inline void swap(int &amp;a, int &amp;b) &#123; tmp = a, a = b, b = tmp; &#125;
inline int max(int a, int b) &#123; return a &gt; b ? a : b; &#125;

inline int read() &#123;
    int ret = 0; char ch = getchar();
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) ch = getchar();
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) ret = ret * 10 + ch - &#39;0&#39;, ch = getchar();
    return ret;
&#125;

int main () &#123;
    n = read(), m = read();
    for(int i = 1; i &lt;= n; ++i) a[i] = read();
    for(int i = 1; i &lt;= m; ++i) u[i] = read(), v[i] = read(), ++deg[u[i]], ++deg[v[i]];
    for(int i = 1; i &lt;= m; ++i) &#123;
        if(deg[u[i]] &lt; deg[v[i]] || (deg[u[i]] == deg[v[i]] &amp;&amp; u[i] &gt; v[i])) swap(u[i], v[i]);
        to[u[i]].push_back(v[i]);
    &#125;
    for(int i = 1; i &lt;= n; ++i) &#123;
        for(auto j : to[i]) vis[j] = i;
        for(auto j : to[i])
            for(auto k : to[j]) &#123;
                if(vis[k] == i) ans += max(max(a[i], a[j]), a[k]);
            &#125;
    &#125; printf(&quot;%lld\n&quot;, ans);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]图论-三元环</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2018 提高组题解</title>
    <url>/2018/12/24/16/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>　　据说是原题积木大赛，但是考场上蠢了，只会写数据结构，于是写了一个线段树$+$堆$+$贪心，先选出最小的，然后区间修改，然后把左右两端区间的最小值丢进堆里，不停从堆中去最小值更新即可（模拟题）</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using std::pop_heap; using std::push_heap;
using std::greater; using std::min;
#define file(a) freopen(a&quot;.in&quot;, &quot;r&quot;, stdin); freopen(a&quot;.out&quot;, &quot;w&quot;, stdout);
typedef long long ll;

template &lt;typename T&gt;
inline void read(T &amp;x) &#123;
    x = 0; char ch = getchar(); int f = 1;
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) f = -f; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar();
    x *= f;
&#125;

const int N = 1e5 + 10, LogN = 20, Inf = 1e9 + 7;
int n, d[N];
struct Range &#123;
    int minval, site, l, r;
    inline bool operator &lt; (const Range &amp;a) const &#123;
        return minval &lt; a.minval;
    &#125;
    inline bool operator &gt; (const Range &amp;a) const &#123;
        return minval &gt; a.minval;
    &#125;
&#125;;
Range val[N &lt;&lt; 2]; int add[N &lt;&lt; 2];
struct Heap &#123;
    Range h[N]; int siz;
    void push(Range x) &#123; h[++siz] = x, push_heap(&amp;h[1], &amp;h[siz + 1], greater&lt;Range&gt;()); &#125;
    void pop() &#123; pop_heap(&amp;h[1], &amp;h[siz + 1], greater&lt;Range&gt;()), --siz; &#125;
    inline bool empty() &#123; return siz == 0; &#125;
    inline int size() &#123; return siz; &#125;
    inline Range top() &#123; return h[1]; &#125;
&#125;q;
inline void pushup(int o, int lc, int rc) &#123;
    val[o] = min(val[lc], val[rc]);
&#125;
inline void pushdown(int o, int lc, int rc) &#123;
    if(add[o]) &#123;
        val[lc].minval += add[o], val[rc].minval += add[o];
        add[lc] += add[o], add[rc] += add[o], add[o] = 0;
    &#125;
&#125;
void build(int o = 1, int l = 1, int r = n) &#123;
    if(l == r) &#123; val[o] = (Range)&#123;d[l], l, l, l&#125;; return ; &#125;
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    build(lc, l, mid), build(rc, mid + 1, r), pushup(o, lc, rc);
&#125;
void modify(int ml, int mr, int k, int o = 1, int l = 1, int r = n) &#123;
    if(ml &gt; mr) return ;
    if(l &gt;= ml &amp;&amp; r &lt;= mr) &#123;
        val[o].minval += k, add[o] += k;
        return ;
    &#125; int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    pushdown(o, lc, rc);
    if(ml &lt;= mid) modify(ml, mr, k, lc, l, mid);
    if(mr &gt; mid) modify(ml, mr, k, rc, mid + 1, r);
    pushup(o, lc, rc);
&#125;
Range query(int ml, int mr, int o = 1, int l = 1, int r = n) &#123;
    if(ml &gt; mr) return (Range)&#123;Inf,0,0,0&#125;;
    if(l &gt;= ml &amp;&amp; r &lt;= mr) return val[o];
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1; Range val = (Range)&#123;Inf,0,0,0&#125;;
    pushdown(o, lc, rc);
    if(ml &lt;= mid) val = query(ml, mr, lc, l, mid);
    if(mr &gt; mid) val = min(val, query(ml, mr, rc, mid + 1, r));
    return val;
&#125;

int main () &#123;
    file(&quot;road&quot;);
    read(n);
    for(int i = 1; i &lt;= n; ++i) read(d[i]);
    build();
    int tmpn = n, ret = 0; Range now = val[1];
    now.l = 1, now.r = n; q.push(now);
    while(tmpn &amp;&amp; q.size()) &#123;
        now = q.top(), q.pop(); --tmpn;
        ret += now.minval;
        modify(now.l, now.r, -now.minval);
        Range l = query(now.l, now.site - 1), r = query(now.site + 1, now.r);
        l.l = now.l, l.r = now.site - 1, r.l = now.site + 1, r.r = now.r;
        q.push(l), q.push(r);
    &#125; printf(&quot;%d\n&quot;, ret);
    return 0;
&#125;
</code></pre>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>　　不难发现，两个硬币系统是等价的当且仅当其中的某些硬币能被除自己以外的硬币凑出来。完全背包强制不选自己就行了。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::max; using std::sort;
#define file(a) freopen(a&quot;.in&quot;, &quot;r&quot;, stdin); freopen(a&quot;.out&quot;, &quot;w&quot;, stdout);
typedef long long ll;

template &lt;typename T&gt;
inline void read(T &amp;x) &#123;
    x = 0; char ch = getchar(); int f = 1;
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) f = -f; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar();
    x *= f;
&#125;

const int N = 1e2 + 10, M = 2.5e4 + 10;
int t, n, a[N], f[M];

int main () &#123;
    file(&quot;money&quot;);
    read(t);
    while(t--) &#123;
        read(n); int ret = 0, m = 0;
        for(int i = 1; i &lt;= n; ++i) read(a[i]), m = max(m, a[i]);
        memset(f, 0, sizeof f), sort(&amp;a[1], &amp;a[n + 1]);
        for(int i = 1; i &lt;= n; ++i) &#123;
            for(int j = a[i] + 1; j &lt;= m; ++j)
                f[j] |= f[j - a[i]];
            if(!f[a[i]]) &#123;
                ++ret, f[a[i]] = 1;
                for(int j = a[i]; j &lt;= m; ++j)
                    f[j] |= f[j - a[i]];
            &#125;
        &#125;
        printf(&quot;%d\n&quot;, ret);
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>　　显然，这种最小值最大可以二分答案，考虑如何$check$，不妨考虑树形$dp$，设$f[u]$表示在$u$的子树中选一条权值和最大的路径，对于一个子节点$v$，如果$f[v]+dis[u][v]$满足，显然可以选，然后在考虑不满足的情况，显然是选择两条路径拼接在一起，可以用$set$+二分搞（其实容易被卡常）。</p>
<pre><code class="lang-cpp">#include &lt;set&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::max; using std::min; using std::sort;
#define file(a) freopen(a&quot;.in&quot;, &quot;r&quot;, stdin); freopen(a&quot;.out&quot;, &quot;w&quot;, stdout);
typedef long long ll;
using std::multiset;

template &lt;typename T&gt;
inline void read(T &amp;x) &#123;
    x = 0; char ch = getchar(); int f = 1;
    while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123; if(ch == &#39;-&#39;) f = -f; ch = getchar(); &#125;
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar();
    x *= f;
&#125;

const int N = 5e4 + 10, Inf = 1e9 + 7;
int n, m, g, k;
int cnt, from[N], to[N &lt;&lt; 1], dis[N &lt;&lt; 1], nxt[N &lt;&lt; 1];
int f[N], st[N]; multiset&lt;int&gt; s; multiset&lt;int&gt;::iterator it;
int l, r;
inline void addEdge(int u, int v, int w) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], dis[cnt] = w, from[u] = cnt;
&#125;

void doit (int u, int fa) &#123;
    for(int i = from[u]; i; i = nxt[i])
        if(to[i] != fa) doit(to[i], u);
    int top = 0;
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; if(v == fa) continue;
        f[v] += dis[i];
        if(f[v] &gt;= g) ++k;
        else st[++top] = f[v];
    &#125; sort(&amp;st[1], &amp;st[top + 1]), s.clear();
    for(int i = 1; i &lt;= top; ++i) &#123;
        it = s.lower_bound(g - st[i]);
        if(it != s.end()) s.erase(it), ++k;
        else s.insert(st[i]);
    &#125;
    f[u] = s.size() ? *s.rbegin() : 0;
&#125;

int main () &#123;
    file(&quot;track&quot;);
    read(n), read(m); 
    for(int i = 1, u, v, w; i &lt; n; ++i) &#123;
        read(u), read(v), read(w), r += w;
        addEdge(u, v, w), addEdge(v, u, w);
    &#125; r /= m; int ret = 0;
    while(l &lt;= r) &#123;
        g = (l + r) &gt;&gt; 1, k = 0;
        doit(1, 0);
        if(k &gt;= m) ret = g, l = g + 1;
        else r = g - 1;
    &#125; printf(&quot;%d\n&quot;, ret);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[竞赛]NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2018游记（更新完毕）</title>
    <url>/2018/12/24/15/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="10-13-初赛-Day-1"><a href="#10-13-初赛-Day-1" class="headerlink" title="10.13 初赛 Day -1"></a>10.13 初赛 Day -1</h2><hr>
<h3 id="考前"><a href="#考前" class="headerlink" title="考前"></a>考前</h3><p>　　这一次的考场从暗♂德华兴改到了长沙市一中，一进去：我一看，考场在哪？？？这一中比长郡大了好多，而且连指示牌都没有，这时碰见了谢总，谢总告诉我们在第二教学楼。路上还碰见了psj和fdf，匆匆忙忙进了考场，发现考场内没什么人，于是决定去上个厕所愉♂悦身心，之后聊了一会天，然后就是宣布考场注意事项，快开考时，发现还是没什么人，说好的<del>没有水军</del>呢？</p>
<hr>
<h3 id="考场上"><a href="#考场上" class="headerlink" title="考场上"></a>考场上</h3><p>　　接到卷子，我突然发现第$5$题竟然考的是$2015$年的原题…€€£啊，你随便考道$master$定理的题都行啊，考什么原题…</p>
<p>　　发现单选题8/9题不太会做，一道卡特兰数的题，第$9$题一道三国杀（甄姬的洛神）概率题，于是先去做不定项。做完选择题后，于是去做问题求解题，第一题送分逻辑题，第二题超级大难题先放着，阅读程序题前两题送分题，第三题有点没看懂，随便写了一个$700$多，我也不知道怎么算的。</p>
<p>　　补全题第一题是一道双向链表题，第一空最初写的$a[i]=x$，后面发现是$a[x]=i$…最后一道是写的特别丑的$dp$，没看懂，勉勉强强写出了前两空</p>
<hr>
<h3 id="考完"><a href="#考完" class="headerlink" title="考完"></a>考完</h3><p>　　出了考场，发现自己忘带身份证，走了$30$分钟又回到了一中，在某个信息老师那里取回了身份证。下午发现答案出了，匆匆一对，应该有$70$分左右，最后两空果不其然错了</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　这一次发挥还算正常，就是最后一题考了个$dp$…蛋疼。然后数学题做的不是很好，唯一想吐槽的就是$2015$年的原题…凉心€€£…</p>
<hr>
<h2 id="11-09-复赛Day0"><a href="#11-09-复赛Day0" class="headerlink" title="11.09 复赛Day0"></a>11.09 复赛Day0</h2><p>上午，复习板子，下午在宣布完一些事情之后开始打摆，$MC$颓爆</p>
<h2 id="11-10-复赛Day1"><a href="#11-10-复赛Day1" class="headerlink" title="11.10 复赛Day1"></a>11.10 复赛Day1</h2><h3 id="上午—提高Day1"><a href="#上午—提高Day1" class="headerlink" title="上午—提高Day1"></a>上午—提高Day1</h3><p>$T1$觉得应该是$O(n)$，但是不会写，脑子不够数据结构来凑，线段树$+$堆$+$贪心模拟一下就行了</p>
<p>$T2$乍一看$O(n^3)$的，但是不会写（菜啊），但是发现等效的货币系统中唯有该面值能被其他面值凑出来。</p>
<p>$O(nm)$完全背包强制不选自己就行了</p>
<p>$T3$这不是原题吗？好像有点不同，而且我没写（因为不会），我只知道可以二分一个答案，但是不会$check$啊，只好打了一个$m=1$走人。</p>
<hr>
<h3 id="下午—普及"><a href="#下午—普及" class="headerlink" title="下午—普及"></a>下午—普及</h3><p>$T1$,$T2$感觉是傻子题。</p>
<p>$T3$不会做，感觉可以贪心，先鸽着</p>
<p>$T4$显然是道$Hash$题，但是我不会$Hash$（菜啊）</p>
<p>$T3$猛然发现不能贪心，$dp$想不到而且没时间写了（$T4$调了好久）</p>
<hr>
<h3 id="晚上—提高自测"><a href="#晚上—提高自测" class="headerlink" title="晚上—提高自测"></a>晚上—提高自测</h3><p>回家收到代码上$Luogu$自测，$T1\&amp;T2$不出意料切了，$T3\ m=1$也拿到了。神仙$nzr\ AK$了。</p>
<h2 id="11-11-复赛Day2"><a href="#11-11-复赛Day2" class="headerlink" title="11.11 复赛Day2"></a>11.11 复赛Day2</h2><h3 id="上午—提高Day2"><a href="#上午—提高Day2" class="headerlink" title="上午—提高Day2"></a>上午—提高Day2</h3><p>各种心态炸裂，三道题目全看错，然后炸裂得了$110$，中间过程没什么好说的:(</p>
<h3 id="下午—睡觉"><a href="#下午—睡觉" class="headerlink" title="下午—睡觉"></a>下午—睡觉</h3><h3 id="晚上—提高自测-1"><a href="#晚上—提高自测-1" class="headerlink" title="晚上—提高自测"></a>晚上—提高自测</h3><p>自测发现本来没有希望的第二题竟然有$50$分？？？</p>
<h2 id="很久之后"><a href="#很久之后" class="headerlink" title="很久之后"></a>很久之后</h2><p>分数线$305$，而我呢？</p>
<script type="math/tex; mode=display">
100+100+20+64+50+0=334</script><p>勉强保住了$1=$，差点$AFO$</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这次$NOIP$算是第一次真真正正考砸了吧，其实这种错误在$HNOI2018$就出现了，当时没多大在意，结果在$NOIP$吃亏了。继续努力吧。</p>
<h2 id="彩蛋（期望得分）"><a href="#彩蛋（期望得分）" class="headerlink" title="彩蛋（期望得分）"></a>彩蛋（期望得分）</h2><script type="math/tex; mode=display">
100+100+100+100+50+44=494</script><p>要是真有这个分数就好了。</p>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>[竞赛]NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P3258 松鼠的新家（树链剖分+线段树/树状数组）</title>
    <url>/2018/12/24/14/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a><a href="https://www.luogu.org/problemnew/show/P3258">题面</a></h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>   　　这种题目一看就是重链剖分裸题，还是区间修改，单点查询，查询之前在遍历时要记一个$delta$，因为这一次的起点就是上一次的终点，不需要放糖，所以可以用$BIT$来写，但我写完$modify$才反应过来，所以没改了。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::swap;

const int N = 3e5 + 10;
int n, a[N], siz[N], son[N], fa[N], dep[N];
int tim, dfn[N], top[N], delta[N];
int cnt, from[N], to[N &lt;&lt; 1], nxt[N &lt;&lt; 1];
int val[N &lt;&lt; 2], add[N &lt;&lt; 2];
inline void addEdge(int u, int v) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], from[u] = cnt;
&#125;

void dfs(int u) &#123;
    siz[u] = 1, dep[u] = dep[fa[u]] + 1;
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; if(v == fa[u]) continue;
        fa[v] = u, dfs(v), siz[u] += siz[v];
        if(siz[v] &gt; siz[son[u]]) son[u] = v;
    &#125;
&#125;
void dfs(int u, int t) &#123;
    dfn[u] = ++tim, top[u] = t;
    if(!son[u]) return ; dfs(son[u], t);
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i];
        if(v != fa[u] &amp;&amp; v != son[u]) dfs(v, v);
    &#125;
&#125;

inline void pushup (int o, int lc, int rc) &#123; val[o] = val[lc] + val[rc]; &#125;
inline void pushdown (int o, int lc, int rc, int len) &#123;
    if(add[o]) &#123;
        val[lc] += add[o] * (len - (len &gt;&gt; 1));
        val[rc] += add[o] * (len &gt;&gt; 1);
        add[lc] += add[o], add[rc] += add[o], add[o] = 0;
    &#125;
&#125;
void modify (int ml, int mr, int k, int o = 1, int l = 1, int r = n) &#123;
    if(l &gt;= ml &amp;&amp; r &lt;= mr) &#123; val[o] += k * (r - l + 1), add[o] += k; return ; &#125;
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1; 
    pushdown(o, lc, rc, r - l + 1); 
    if(ml &lt;= mid) modify(ml, mr, k, lc, l, mid);
    if(mr &gt; mid) modify(ml, mr, k, rc, mid + 1, r);
    pushup(o, lc, rc);
&#125;
int query(int qs, int o = 1, int l = 1, int r = n) &#123;
    if(l == r &amp;&amp; l == qs) return val[o];
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1; 
    pushdown(o, lc, rc, r - l + 1); 
    if(qs &lt;= mid) return query(qs, lc, l, mid);
    else return query(qs, rc, mid + 1, r);
&#125;

inline void Path(int x, int y) &#123;
    int fx = top[x], fy = top[y];
    while(fx != fy) &#123;
        if(dep[fx] &gt;= dep[fy]) modify(dfn[fx], dfn[x], 1), x = fa[fx], fx = top[x];
        else modify(dfn[fy], dfn[y], 1), y = fa[fy], fy = top[y];
    &#125; if(dfn[x] &gt; dfn[y]) swap(x, y); modify(dfn[x], dfn[y], 1);
&#125;

int main () &#123;
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i);
    for(int i = 1, u, v; i &lt; n; ++i) &#123;
        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        addEdge(u, v), addEdge(v, u);
    &#125;
    dfs(1), dfs(1, 1);
    for(int i = 2; i &lt;= n; ++i)
        Path(a[i - 1], a[i]), ++delta[a[i]];
    for(int i = 1; i &lt;= n; ++i)
        printf(&quot;%d\n&quot;, query(dfn[i]) - delta[i]);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]树论-树链剖分</tag>
        <tag>[C++]数据结构-线段树</tag>
        <tag>[C++]数据结构-树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Poj1151&amp;HDU1542 Atlantis（扫描线+线段树）</title>
    <url>/2018/12/24/13/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定$n​$个矩形$(x_1,y_1,x_2,y_2)​$，求这$n​$个矩形的面积并</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>扫描线裸题，可以不用线段树维护，$O(n^2)$是允许的。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::sort;
using std::unique;
using std::lower_bound;

const int N = 1e2 + 10;
int n, m, tot;
double ans, x1[N], y1[N], x2[N], y2[N], raw[N &lt;&lt; 1], tmp[N &lt;&lt; 1];
struct Node &#123;
    double x, dy, uy, g; 
    inline bool operator &lt; (const Node &amp;a) const &#123; return x &lt; a.x; &#125;
&#125; cy[N &lt;&lt; 1]; int cnt;
double val[N &lt;&lt; 3]; int fg[N &lt;&lt; 3];

inline void update(int o, int l, int r) &#123;
    if(fg[o]) val[o] = raw[r + 1] - raw[l];
    else if(l == r) val[o] = 0;
    else val[o] = val[o &lt;&lt; 1] + val[o &lt;&lt; 1 | 1];
&#125;
void modify (int ml, int mr, int k, int o = 1, int l = 1, int r = m) &#123;
    if(l &gt;= ml &amp;&amp; r &lt;= mr) &#123;
        fg[o] += k, update(o, l, r);
        return ;
    &#125;
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    if(ml &lt;= mid) modify(ml, mr, k, lc, l, mid);
    if(mr &gt; mid) modify(ml, mr, k, rc, mid + 1, r);
    update(o, l, r);
&#125;

int main () &#123;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF) &#123;
        if(!n) break; ++tot; ans = m = cnt = 0;
        memset(val, 0, sizeof val), memset(fg, 0, sizeof fg);
        for(int i = 1; i &lt;= n; ++i) &#123;
            scanf(&quot;%lf%lf%lf%lf&quot;, x1 + i, y1 + i, x2 + i, y2 + i);
            tmp[++m] = y1[i], tmp[++m] = y2[i];
        &#125;
        sort(&amp;tmp[1], &amp;tmp[m + 1]); m = unique(&amp;tmp[1], &amp;tmp[m + 1]) - tmp - 1;
        for(int i = 1; i &lt;= n; ++i) &#123;
            int ind1 = lower_bound(&amp;tmp[1], &amp;tmp[m + 1], y1[i]) - tmp;
            int ind2 = lower_bound(&amp;tmp[1], &amp;tmp[m + 1], y2[i]) - tmp;
            raw[ind1] = y1[i], raw[ind2] = y2[i], y1[i] = ind1, y2[i] = ind2;
        &#125;
        for(int i = 1; i &lt;= n; ++i) &#123;
            cy[++cnt] = (Node)&#123;x1[i], y1[i], y2[i], 1&#125;;
            cy[++cnt] = (Node)&#123;x2[i], y1[i], y2[i], -1&#125;;
        &#125; sort(&amp;cy[1], &amp;cy[cnt + 1]);
        for(int i = 1; i &lt;= cnt; ++i) &#123;
            modify(cy[i].dy, cy[i].uy - 1, cy[i].g);
            ans += val[1] * (cy[i + 1].x - cy[i].x);
        &#125;
        printf(&quot;Test case #%d\nTotal explored area: %.2lf\n\n&quot;, tot, ans);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-线段树</tag>
        <tag>[C++]计算几何-扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>Loj10222 佳佳的Fibonacci（矩阵乘法）</title>
    <url>/2018/12/24/12/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给定$n,m$，求：</p>
<script type="math/tex; mode=display">
T(n)=\sum_{i=1}^ni\times f_i</script><p>其中$f_i$为斐波那契数列的第$i$项</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>不妨设：</p>
<script type="math/tex; mode=display">
S(n)=\sum_{i=1}^nf_i</script><p>则可以设：</p>
<script type="math/tex; mode=display">
P(n)=nS(n)-T(n)=\sum_{i=1}^{n-1}(n-i)\times f_i</script><p>所以有：</p>
<script type="math/tex; mode=display">
P(n+1)=\sum_{i=1}^{n}(n+1-i)\times f_i=\sum_{i=1}^n(n-i)\times f_i+\sum_{i=1}^nf_i\\
=\sum_{i=1}^{n-1}(n-i)\times f_i+0\times f_n+S(n)=P(n)+S(n)</script><p>然后就可以用矩阵乘法加速递推了。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;

int n, m;
struct Matrix &#123;
    int a[4][4];
    Matrix() &#123; memset(a, 0, sizeof a); &#125;
    inline int* operator [] (const int &amp;x) &#123; return a[x]; &#125;
    inline Matrix operator * (Matrix &amp;b) const &#123;
        Matrix ret;
        for(int i = 0; i &lt; 4; ++i)
            for(int k = 0; k &lt; 4; ++k)
                for(int j = 0; j &lt; 4; ++j)
                    (ret[i][j] += 1ll * a[i][k] * b[k][j] % m) %= m;
        return ret;
    &#125;
&#125; S, T;

int main () &#123;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int k = n;
    S[0][1] = 1;
    T[0][0] = T[0][1] = T[0][2] = 1;
    T[1][0] = T[1][2] = 1;
    T[2][2] = T[2][3] = 1;
    T[3][3] = 1;
    while(k) &#123;
        if(k &amp; 1) S = S * T;
        T = T * T, k &gt;&gt;= 1;
    &#125;
    printf(&quot;%lld\n&quot;, (1ll * n * S[0][2] % m + m - S[0][3]) % m);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]数论-矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P2016 战略游戏（树形DP）</title>
    <url>/2018/12/24/11/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>设$f[u][0/1/2]$表示当前节点$u$，放或不放（$0/1$）时其子树满足题目要求的最小代价，$2$表示$0/1$中的最小值。</p>
<p>则有：</p>
<script type="math/tex; mode=display">
f[u][0]=\sum_{v\in son[u]}f[v][1]\\
f[u][1]=\sum_{v\in son[u]}f[v][2]\\
f[u][2]=min(f[u][0],f[u][1])</script><p>$O(n)$即可</p>
<hr>
<p>PS:作者在写代码时忘记找根节点了，但是数据太水，默认$0$为根节点了。在写这种题时记得寻找根节点！！</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using std::min;
typedef long long ll;

const int N = 1.5e3 + 10, Inf = 1e9 + 7;
int n, f[N][3];
int cnt, from[N], to[N], nxt[N];//Edges
inline void addEdge(int u, int v) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], from[u] = cnt;
&#125;

void dp(int u) &#123;
    f[u][1] = 1, f[u][0] = 0;
    for(int i = from[u], v; i; i = nxt[i])
        v = to[i], dp(v), f[u][1] += f[v][2], f[u][0] += f[v][1];
    f[u][2] = min(f[u][1], f[u][0]);
&#125;

int main () &#123;
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 1, u, tot; i &lt;= n; ++i) &#123;
        scanf(&quot;%d%d&quot;, &amp;u, &amp;tot);
        for(int j = 1, v; j &lt;= tot; ++j)
            scanf(&quot;%d&quot;, &amp;v), addEdge(u, v);
    &#125;
    dp(0);
    printf(&quot;%d\n&quot;, f[0][2]);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]动态规划-树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P2486 染色（树链剖分+线段树）</title>
    <url>/2018/12/24/10/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>不妨采取重链剖分的方式把路径剖成区间，然后用线段树维护，考虑如何合并一个区间</p>
<pre><code class="lang-cpp">struct Node &#123;
    int lf, rg, tot;
&#125;seg[N &lt;&lt; 2]; int col[N &lt;&lt; 2];
inline Node merge(const Node &amp;lc, const Node &amp;rc) &#123;
    if(!lc.tot) return rc;
    if(!rc.tot) return lc;
    Node ret = (Node)&#123;lc.lf, rc.rg, lc.tot + rc.tot&#125;;
    if(lc.rg == rc.lf) --ret.tot;
    return ret;
&#125;
</code></pre>
<p>其中$Node$表示线段树中的一个节点，共有三个参数，左端点颜色，右端点颜色以及区间内颜色段数。$col$数组用于下方染色标记。</p>
<p>但是我们要考虑这个区间合并后是否存在相同的颜色其应该只有$1$的贡献却被记了$2$的贡献。这种情况存在当且仅当左区间的右端点颜色与右区间左端点颜色相同。</p>
<p>接着，有关于线段树的其他操作也没有什么好担心的了，接着考虑如何查询。</p>
<pre><code class="lang-cpp">inline int doit(int x, int y) &#123;
    int fx = top[x], fy = top[y];
    Node disx = (Node)&#123;0, 0, 0&#125;, disy = (Node)&#123;0, 0, 0&#125;;
    while(fx != fy) &#123;
        if(dep[fx] &gt;= dep[fy]) disx = merge(query(dfn[fx], dfn[x]), disx), x = fa[fx], fx = top[x];
        else disy = merge(query(dfn[fy], dfn[y]), disy), y = fa[fy], fy = top[y];
    &#125; if(dfn[x] &gt; dfn[y]) swap(x, y), swap(disx, disy);
    swap(disx.lf, disx.rg);
    Node ret = merge(merge(disx, query(dfn[x], dfn[y])), disy);
    return ret.tot;
&#125;
</code></pre>
<p>由于重链剖分跳$top$时，两个端点的路径是独立的，所以不能像普通查询那样直接累加贡献，要分开处理，最后存在一个特殊情况，要将左区间的左右端点反置。（画图即可明白）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using std::swap;
typedef long long ll;

const int N = 1e5 + 10;
int n, m, c[N], w[N];
int fa[N], son[N], siz[N], dep[N];
int time, dfn[N], top[N];
int cnt, from[N], to[N &lt;&lt; 1], nxt[N &lt;&lt; 1];
    struct Node &#123;
        int lf, rg, tot;
    &#125;seg[N &lt;&lt; 2]; int col[N &lt;&lt; 2];

void addEdge(int u, int v) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], from[u] = cnt;
&#125;

void dfs(int u) &#123;
    dep[u] = dep[fa[u]] + 1, siz[u] = 1;
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; if(v == fa[u]) continue;
        fa[v] = u, dfs(v), siz[u] += siz[v];
        if(siz[v] &gt; siz[son[u]]) son[u] = v;
    &#125;
&#125;
void dfs(int u, int t) &#123;
    dfn[u] = ++time, top[u] = t, w[time] = c[u];
    if(!son[u]) return ; dfs(son[u], t);
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i];
        if(v != fa[u] &amp;&amp; v != son[u])
            dfs(v, v);
    &#125;
&#125;

inline Node merge(const Node &amp;lc, const Node &amp;rc) &#123;
    if(!lc.tot) return rc;
    if(!rc.tot) return lc;
    Node ret = (Node)&#123;lc.lf, rc.rg, lc.tot + rc.tot&#125;;
    if(lc.rg == rc.lf) --ret.tot;
    return ret;
&#125;
inline void pushdown(int o, int lc, int rc) &#123;
    if(col[o]) &#123;
        seg[lc] = (Node)&#123;col[o], col[o], 1&#125;;
        seg[rc] = (Node)&#123;col[o], col[o], 1&#125;;
        col[lc] = col[rc] = col[o], col[o] = 0;
    &#125;
&#125;
void build(int o = 1, int l = 1, int r = n) &#123;
    if(l == r) &#123; seg[o] = (Node)&#123;w[l], w[l], 1&#125;; return ; &#125;
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    build(lc, l, mid), build(rc, mid + 1, r), seg[o] = merge(seg[lc], seg[rc]);
&#125;
void color(int cl, int cr, int k, int o = 1, int l = 1, int r = n) &#123;
    if(l &gt;= cl &amp;&amp; r &lt;= cr) &#123;
        seg[o] = (Node)&#123;k, k, 1&#125;, col[o] = k;
        return ;
    &#125;
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    pushdown(o, lc, rc);
    if(cl &lt;= mid) color(cl, cr, k, lc, l, mid);
    if(cr &gt; mid) color(cl, cr, k, rc, mid + 1, r);
    seg[o] = merge(seg[lc], seg[rc]);
&#125;
Node query(int ql, int qr, int o = 1, int l = 1, int r = n) &#123;
    if(l &gt;= ql &amp;&amp; r &lt;= qr) return seg[o];
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    Node ret = (Node)&#123;0, 0, 0&#125;;
    pushdown(o, lc, rc);
    if(ql &lt;= mid) ret = query(ql, qr, lc, l, mid);
    if(qr &gt; mid) ret = merge(ret, query(ql, qr, rc, mid + 1, r));
    return ret;
&#125;

inline void upt(int x, int y, int k) &#123;
    int fx = top[x], fy = top[y];
    while(fx != fy) &#123;
        if(dep[fx] &gt;= dep[fy]) color(dfn[fx], dfn[x], k), x = fa[fx], fx = top[x];
        else color(dfn[fy], dfn[y], k), y = fa[fy], fy = top[y];
    &#125; if(dfn[x] &gt; dfn[y]) swap(x, y);
    color(dfn[x], dfn[y], k);
&#125;
inline int doit(int x, int y) &#123;
    int fx = top[x], fy = top[y];
    Node disx = (Node)&#123;0, 0, 0&#125;, disy = (Node)&#123;0, 0, 0&#125;;
    while(fx != fy) &#123;
        if(dep[fx] &gt;= dep[fy]) disx = merge(query(dfn[fx], dfn[x]), disx), x = fa[fx], fx = top[x];
        else disy = merge(query(dfn[fy], dfn[y]), disy), y = fa[fy], fy = top[y];
    &#125; if(dfn[x] &gt; dfn[y]) swap(x, y), swap(disx, disy);
    swap(disx.lf, disx.rg);
    Node ret = merge(merge(disx, query(dfn[x], dfn[y])), disy);
    return ret.tot;
&#125;

int main () &#123;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, c + i);
    for (int i = 1, u, v; i &lt; n; ++i) &#123;
        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        addEdge(u, v), addEdge(v, u);
    &#125;
    dfs(1), dfs(1, 1), build();
    char opt; int a, b, c;
    while(m--) &#123;
        scanf(&quot;\n%c%d%d&quot;, &amp;opt, &amp;a, &amp;b);
        if(opt == &#39;C&#39;) &#123;
            scanf(&quot;%d&quot;, &amp;c);
            upt(a, b, c);
        &#125; else printf(&quot;%d\n&quot;, doit(a, b));
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]树论-树链剖分</tag>
        <tag>[C++]数据结构-线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P3178 树上操作（树链剖分+线段树）</title>
    <url>/2018/12/24/9/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>见原题</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>重链剖分模板题</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using std::swap;
typedef long long ll;

const int N = 1e5 + 10;
int n, m, c[N], opt, x, y;
int dep[N], siz[N], fa[N], son[N];
int top[N], dfn[N], w[N], time;
int cnt, from[N], to[N &lt;&lt; 1], nxt[N &lt;&lt; 1];
ll val[N &lt;&lt; 2], add[N &lt;&lt; 2];
inline void addEdge(int u, int v)&#123;
    to[++cnt] = v, nxt[cnt] = from[u], from[u] = cnt;
&#125;

void dfs1(int u) &#123;
    dep[u] = dep[fa[u]] + 1, siz[u] = 1;
    for (int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; if(v == fa[u]) continue;
        fa[v] = u, dfs1(v), siz[u] += siz[v];
        if(siz[v] &gt; siz[son[u]]) son[u] = v;
    &#125;
&#125;
void dfs2(int u, int t) &#123;
    top[u] = t, dfn[u] = ++time, w[time] = c[u];
    if(!son[u]) return ; dfs2(son[u], t);
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i];
        if(v != fa[u] &amp;&amp; v != son[u])
            dfs2(v, v);
    &#125;
&#125;

inline void pushup(int o, int lc, int rc) &#123;
    val[o] = val[lc] + val[rc];
&#125;
inline void pushdown(int o, int lc, int rc, int len) &#123;
    if(add[o]) &#123;
        add[lc] += add[o], add[rc] += add[o];
        val[lc] += add[o] * (len - (len &gt;&gt; 1));
        val[rc] += add[o] * (len &gt;&gt; 1);
        add[o] = 0;
    &#125;
&#125;
void build(int o = 1, int l = 1, int r = n) &#123;
    if(l == r) &#123; val[o] = w[l]; return ; &#125;
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    build(lc, l, mid), build(rc, mid + 1, r), pushup(o, lc, rc);
&#125;
void upt(int ul, int ur, ll k, int o = 1, int l = 1, int r = n) &#123;
    if (l &gt;= ul &amp;&amp; r &lt;= ur) &#123;
        add[o] += k, val[o] += k * (r - l + 1);
        return ;
    &#125;
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    pushdown(o, lc, rc, r - l + 1);
    if(ul &lt;= mid) upt(ul, ur, k, lc, l, mid);
    if(ur &gt; mid) upt(ul, ur, k, rc, mid + 1, r);
    pushup(o, lc, rc);
&#125;
ll que(int ql, int qr, int o = 1, int l = 1, int r = n) &#123;
    if (l &gt;= ql &amp;&amp; r &lt;= qr) return val[o];
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1; ll ret = 0;
    pushdown(o, lc, rc, r - l + 1);
    if(ql &lt;= mid) ret = que(ql, qr, lc, l, mid);
    if(qr &gt; mid) ret += que(ql, qr, rc, mid + 1, r);
    return ret;
&#125;

ll sum(int x) &#123;
    int fx = top[x]; ll ret = 0;
    while (fx != 1) ret += que(dfn[fx], dfn[x]), x = fa[fx], fx = top[x];
    return ret + que(1, dfn[x]);
&#125;

int main () &#123;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, c + i);
    for (int i = 1, u, v; i &lt; n; ++i) &#123;
        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        addEdge(u, v), addEdge(v, u);
    &#125;
    dfs1(1), dfs2(1, 1), build();
    while(m--) &#123;
        scanf(&quot;%d%d&quot;, &amp;opt, &amp;x);
        if (opt == 3) printf(&quot;%lld\n&quot;, sum(x));
        else &#123;
            scanf(&quot;%d&quot;, &amp;y);
            if (opt == 1) upt(dfn[x], dfn[x], y);
            else upt(dfn[x], dfn[x] + siz[x] - 1, y);
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]树论-树链剖分</tag>
        <tag>[C++]数据结构-线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P2590 树的统计（树链剖分+线段树）</title>
    <url>/2018/12/24/8/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>原文很清楚了</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>重链剖分模板题，用线段树维护即可。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::max;
using std::swap;

const int N = 3e4 + 10, Inf = 1e9 + 7;
int n, q, c[N], x, y;
int fa[N], dep[N], son[N], siz[N];
int top[N], w[N], dfn[N], time;
int cnt, from[N], to[N &lt;&lt; 1], nxt[N &lt;&lt; 1];//Edges;
int maxv[N &lt;&lt; 2], sumv[N &lt;&lt; 2];//SegTree
inline void addEdge(int u, int v) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], from[u] = cnt;
&#125;

void dfs1(int u) &#123;
    siz[u] = 1, dep[u] = dep[fa[u]] + 1;
    for (int i = from[u]; i; i = nxt[i]) &#123;
    int v = to[i]; if(v == fa[u]) continue;
    fa[v] = u, dfs1(v), siz[u] += siz[v];
    if(siz[v] &gt; siz[son[u]]) son[u] = v;
    &#125;
&#125;
void dfs2(int u, int t) &#123;
    top[u] = t, dfn[u] = ++time, w[time] = c[u];
    if(!son[u]) &#123; return ; &#125; dfs2(son[u], t);
    for (int i = from[u]; i; i = nxt[i]) &#123;
    int v = to[i];
    if (v != fa[u] &amp;&amp; v != son[u])
        dfs2(v, v);
    &#125;        
&#125;

void pushup (int o, int lc, int rc) &#123;
    sumv[o] = sumv[lc] + sumv[rc];
    maxv[o] = max(maxv[lc], maxv[rc]);
&#125;
void build(int o = 1, int l = 1, int r = n) &#123;
    if(l == r) &#123; sumv[o] = maxv[o] = w[l]; return ; &#125;
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    build(lc, l, mid), build(rc, mid + 1, r), pushup(o, lc, rc);
&#125;
void modify(int p, int k, int o = 1, int l = 1, int r = n) &#123;
    if(l == r &amp;&amp; l == p) &#123; sumv[o] = maxv[o] = k; return ; &#125;
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    if(p &lt;= mid) modify(p, k, lc, l, mid);
    else modify(p, k, rc, mid + 1, r);
    pushup(o, lc, rc);
&#125;
int quemax(int ql, int qr, int o = 1, int l = 1, int r = n) &#123;
    if(l &gt;= ql &amp;&amp; r &lt;= qr) return maxv[o];
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1, ret = -Inf;
    if(ql &lt;= mid) ret = quemax(ql, qr, lc, l, mid);
    if(qr &gt; mid) ret = max(ret, quemax(ql, qr, rc, mid + 1, r));
    return ret;
&#125;
int quesum(int ql, int qr, int o = 1, int l = 1, int r = n) &#123;
    if(l &gt;= ql &amp;&amp; r &lt;= qr) return sumv[o];
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1, ret = 0;
    if(ql &lt;= mid) ret = quesum(ql, qr, lc, l, mid);
    if(qr &gt; mid) ret += quesum(ql, qr, rc, mid + 1, r);
    return ret;
&#125;

int quem(int x, int y) &#123;
    int fx = top[x], fy = top[y], ret = -Inf;
    while(fx != fy) &#123;
    if(dep[fx] &gt;= dep[fy])
        ret = max(ret, quemax(dfn[fx], dfn[x])), x = fa[fx], fx = top[x];
    else
        ret = max(ret, quemax(dfn[fy], dfn[y])), y = fa[fy], fy = top[y];
    &#125;
    if(dfn[x] &gt; dfn[y]) swap(x, y);
    return max(ret, quemax(dfn[x], dfn[y]));
&#125;
int ques(int x, int y) &#123;
    int fx = top[x], fy = top[y], ret = 0;
    while(fx != fy) &#123;
    if(dep[fx] &gt;= dep[fy])
        ret += quesum(dfn[fx], dfn[x]), x = fa[fx], fx = top[x];
    else
        ret += quesum(dfn[fy], dfn[y]), y = fa[fy], fy = top[y];
    &#125;
    if(dfn[x] &gt; dfn[y]) swap(x, y);
    return ret + quesum(dfn[x], dfn[y]);
&#125;


int main () &#123;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1, u, v; i &lt; n; ++i) &#123;
    scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
    addEdge(u, v), addEdge(v, u);
    &#125;
    for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;c[i]);
    dfs1(1), dfs2(1, 1);
    build();
    scanf(&quot;%d&quot;, &amp;q);
    char opt[10];
    while(q--) &#123;
    scanf(&quot;\n%s %d %d&quot;, opt, &amp;x, &amp;y);
    if(opt[0] == &#39;Q&#39;) &#123;
        if(opt[1] == &#39;M&#39;) printf(&quot;%d\n&quot;, quem(x, y));
        else printf(&quot;%d\n&quot;, ques(x, y));
    &#125; else modify(dfn[x], y);
    &#125;
    return 0;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]树论-树链剖分</tag>
        <tag>[C++]数据结构-线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P2146 软件包管理器（树链剖分+线段树）</title>
    <url>/2018/12/24/7/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定$n$个软件包，每个软件包都有一个依赖软件包，安装一个软件包必须安装他的依赖软件包，卸载一个软件包必须先卸载所有依赖于它的软件包。给定$m$此操作，每次一个操作$install/unistall$表示安装或者卸载。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>可以通过简单画图看出，在这个树形结构的依赖层次图上，安装一个包相当于安装其到根节点路径上的所有包，删除一个包相当于删除其与其子树的包。用一个重链剖分+线段树处理一下就行了。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using std::swap;
typedef long long ll;

const int N = 1e5 + 10;
int n, Q, x, ans;
int fa[N], dep[N], siz[N], son[N];
int top[N], dfn[N], time;
int cnt, from[N], to[N], nxt[N];
int bui[N &lt;&lt; 2], set[N &lt;&lt; 2];
inline void addEdge(int u, int v) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], from[u] = cnt;
&#125;

void dfs1(int u) &#123;
    siz[u] = 1, dep[u] = dep[fa[u]] + 1;
    for (int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; dfs1(v), siz[u] += siz[v];
        if(siz[v] &gt; siz[son[u]]) son[u] = v;
    &#125;
&#125;
void dfs2(int u, int t) &#123;
    dfn[u] = ++time, top[u] = t;
    if(!son[u]) return ; dfs2(son[u], t);
    for(int i = from[u]; i; i = nxt[i]) &#123;
        int v = to[i]; if(v == son[u]) continue;
        dfs2(v, v);
    &#125;
&#125;
void modify(int sl, int sr, int k, int o = 1, int l = 1, int r = n) &#123;
    int len = r - l + 1;
    if(l &gt;= sl &amp;&amp; r &lt;= sr) &#123;
        if(k == 1) ans += len - bui[o], bui[o] = len;
        else ans += bui[o], bui[o] = 0;
        set[o] = k;
        return ;
    &#125;
    int mid = (l + r) &gt;&gt; 1, lc = o &lt;&lt; 1, rc = lc | 1;
    if(set[o]) &#123;
        if(set[o] == 1) bui[lc] = (len - (len &gt;&gt; 1)), bui[rc] = (len &gt;&gt; 1);
        else bui[lc] = bui[rc] = 0;
        set[lc] = set[rc] = set[o], set[o] = 0;
    &#125;
    if(sl &lt;= mid) modify(sl, sr, k, lc, l, mid);
    if(sr &gt; mid) modify(sl, sr, k, rc, mid + 1, r);
    bui[o] = bui[lc] + bui[rc];
&#125;
inline void ins(int x) &#123;
    int fx = top[x];
    while (fx != 1) modify(dfn[fx], dfn[x], 1), x = fa[fx], fx = top[x];
    modify(1, dfn[x], 1);
&#125;

int main () &#123;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 2; i &lt;= n; ++i) &#123;
        scanf(&quot;%d&quot;, fa + i), ++fa[i];
        addEdge(fa[i], i);
    &#125;
    dfs1(1), dfs2(1, 1);
    scanf(&quot;%d&quot;, &amp;Q);
    char opt[12];
    while(Q--) &#123;
        scanf(&quot;\n%s%d&quot;, opt, &amp;x), ans = 0, ++x;
        if(opt[0] == &#39;i&#39;) ins(x);
        else modify(dfn[x], dfn[x] + siz[x] - 1, -1);
        printf(&quot;%d\n&quot;, ans);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]树论-树链剖分</tag>
        <tag>[C++]数据结构-线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>cdq分治学习笔记</title>
    <url>/2018/12/24/6/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>感谢$__stdcall$的讲解，感谢伟大的导师$_tham$提供一系列练手题</p>
<h2 id="cdq分治是什么？"><a href="#cdq分治是什么？" class="headerlink" title="cdq分治是什么？"></a>cdq分治是什么？</h2><p>国人（<del>陈丹琦</del>）引进的算法，不同于一般的分治，我们常说的分治是将问题分成互不影响的几个区间，递归进行处理，而所谓$cdq$分治，在处理一个区间时，还要计算它对其他区间的贡献。</p>
<h2 id="二维偏序问题"><a href="#二维偏序问题" class="headerlink" title="二维偏序问题"></a>二维偏序问题</h2><blockquote>
<p>给定$n$个二元组$[a,b]$，$m$次询问，每次给定其中的一个二元组$[c,d]$，求满足条件$c&lt;a\&amp;d&lt;b$的二元组的个数</p>
</blockquote>
<p>不知道怎么做？逆序对你总会求吧？逆序对就是一种经典的二维偏序问题，我们不妨这样转换逆序对问题：</p>
<blockquote>
<p>给定$n$个数，定义一个二元组为$[$元素下标，元素值$]$，则共有$n$个这样的二元组</p>
</blockquote>
<p>我们只需将约束条件改为：$c<a\&d>b$就行了。</p>
<p>那么，解决二维偏序的一般模式，也只需要改一下合并时的那一句话就好了。</p>
<p>PS：啊？你忘了怎么用归并排序求逆序对？<a href="https://www.cnblogs.com/water-mi/p/9811731.html">戳我</a></p>
<p>相同的，我们也可以用树状数组来求解。复杂度同样为$O(nlogn)$</p>
<hr>
<p>既然我们能用树状数组来解决用$cdq$分治的题，那我们能不能用$cdq$分治来解决树状数组的题目呢？当然可以，比如这道：<a href="https://www.luogu.org/problemnew/show/P3374">Luogu3374 树状数组1</a></p>
<blockquote>
<p>给定一个$n​$个元素的序列$a​$，初始值全部为$0​$，对这个序列进行以下两种操作</p>
<p>操作$1$：格式为$1\ x\ k$，把所有位置$x$的元素加上$k$</p>
<p>操作$2$：格式为$2 x y$，求出区间$[x,y]$内所有元素的和。</p>
</blockquote>
<p>这显然是一道树状数组模板题，考虑如何用$cdq$分治来解决它。</p>
<p>我们不妨以修改的时间为第一关键字，修改元素的位置为第二关键字。由于时间已经有序，我们定义结构体包含$3$个元素：$opt,ind,val$，其中$ind$表示操作的位置，$opt$为$1$表示修改，$val$表示“加上的值”。而对于查询，我们用前缀和的思想把他分解成两个操作：$sum[1,y]-sum[1,x-1]$，即分解成两次前缀和的查询。在合并的过程中，$opt$为$2$表示遇到了一个查询的左端点$x-1$，对结果作负贡献，$opt$为$3$表示遇到了一个查询的右端点$y$，对结果作正贡献，$val$表示“是第几个查询”。这样，我们就把每个操作转换成了带有附加信息的有序对(时间，位置)，然后对整个序列进行$cdq$分治。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::min;
using std::max;
using std::swap;
using std::sort;
typedef long long ll;

const int N = 5e5 + 10, M = 5e5 + 10;
int n, m, aid, qid;
ll ans[M];
struct Query &#123;
    int ind, opt; ll val;
    inline bool operator &lt; (const Query a) const &#123;
        return ind == a.ind ? opt &lt; a.opt : ind &lt; a.ind;
    &#125;
&#125;q[(M &lt;&lt; 1) + N], tmp[(M &lt;&lt; 1) + N];

inline void cdq (int l, int r) &#123;
    if (l == r) return ;
    int mid = (l + r) &gt;&gt; 1;
    cdq(l, mid), cdq(mid + 1, r);
    int i = l, j = mid + 1, p = l; ll sum = 0;
    while (i &lt;= mid &amp;&amp; j &lt;= r)
        if (q[i] &lt; q[j]) &#123;
            if (q[i].opt == 1) sum += q[i].val;
            tmp[p++] = q[i++];
        &#125; else &#123;
            if (q[j].opt == 2) ans[q[j].val] -= sum;
            if (q[j].opt == 3) ans[q[j].val] += sum;
            tmp[p++] = q[j++];
        &#125;
    while (i &lt;= mid) &#123; if (q[i].opt == 1) sum += q[i].val; tmp[p++] = q[i++]; &#125;
    while (j &lt;= r) &#123;
        if (q[j].opt == 2) ans[q[j].val] -= sum;
        if (q[j].opt == 3) ans[q[j].val] += sum;
        tmp[p++] = q[j++];
    &#125;
    for (int k = l; k &lt;= r; ++k) q[k] = tmp[k];    
&#125;

int main () &#123;
    scanf (&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i) &#123;
        q[++qid].ind = i, q[qid].opt = 1;
        scanf(&quot;%lld&quot;, &amp;q[qid].val);
    &#125;
    int opt, ind, l, r; ll val;
    for (int i = 1; i &lt;= m; ++i) &#123;
        scanf(&quot;%d&quot;, &amp;opt);
        if (opt == 1) scanf(&quot;%d%lld&quot;, &amp;ind, &amp;val), q[++qid] = (Query)&#123;ind, 1, val&#125;;
        else &#123;
            scanf (&quot;%d%d&quot;, &amp;l, &amp;r);
            q[++qid] = (Query)&#123;l - 1, 2, ++aid&#125;, q[++qid] = (Query)&#123;r, 3, aid&#125;;
        &#125;
    &#125;
    cdq(1, qid);
    for (int i = 1; i &lt;= aid; ++i)
        printf(&quot;%lld\n&quot;, ans[i]);
    return 0;
&#125;
</code></pre>
<hr>
<h2 id="三维偏序问题"><a href="#三维偏序问题" class="headerlink" title="三维偏序问题"></a>三维偏序问题</h2><blockquote>
<p>给定$n$个三元组$[a,b,c]$，$m$次询问，每次给定其中的一个二元组$[d,e,f]$，求满足条件$d&lt;a\&amp;e&lt;b\&amp;f&lt;c$的二元组的个数</p>
</blockquote>
<p>相同的，我们也可以采取用其他方法来解决三位偏序问题，如$bitset$、$KD\ Tree$、树套树等…比如我们可以以$a$为关键字排序，同时用$BIT$套平衡树来维护剩下的两个元素。</p>
<p>接着考虑如何用$cdq$分治来解决这个问题，我们可以考虑先以$a$为关键字对数组排序，这样我们的问题就成了维护后两个元素了。接下来，我们以一个经典的三维偏序题：陌上花开来做具体说明（由于这道题较为经典，在各大$OJ$都能找到，不给出链接）</p>
<hr>
<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><blockquote>
<p><strong>有n朵花，每朵花有三个属性：花形(s)、颜色(c)、气味(m)，由三个整数表示。现要对每朵花评级，一朵花的级别是它拥有的美丽能超过的花的数量。定义一朵花A比花B要美丽，当且仅Sa&gt;=Sb,Ca&gt;=Cb,Ma&gt;=Mb。显然，两朵花可能有同样的属性。需要统计出评出每个等级的花的数量。</strong></p>
</blockquote>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ol>
<li>就如刚才所说的，以$a$为关键字进行排序</li>
</ol>
<pre><code class="lang-cpp">struct Node &#123;
    int a, b, c, mult, ans;
    inline void Init() &#123;
        read(a), read(b), read(c);
    &#125;
&#125; v[N], d[N];
inline bool cmpx (Node x, Node y) &#123;
    return (x.a &lt; y.a) || (x.a == y.a &amp;&amp; x.b &lt; y.b) || (x.a == y.a &amp;&amp; x.b == y.b &amp;&amp; x.c &lt; y.c);
&#125;
int main () &#123;
    read(n), read(k);
    for (int i = 1; i &lt;= n; ++i) v[i].Init();
    sort(&amp;v[1], &amp;v[n + 1], cmpx);
&#125;
</code></pre>
<ol>
<li>然后，我们会发现，普通的三位偏序只用处理小于，而不是小于等于，根据题意，完全相同属性的花是不计算在内的，所以我们得考虑将其去重。</li>
</ol>
<pre><code class="lang-cpp">for (int i = 1; i &lt;= n; ++i) &#123;
    ++mul;//相同元素的个数
    //这里的异或你可以理解为不等于，由于之前已经排过序（见函数cmpx），可以线性比较，mult表示重复元素的个数
    if ((v[i].a ^ v[i + 1].a) || (v[i].b ^ v[i + 1].b) || (v[i].c ^ v[i + 1].c))
        d[++m] = v[i], d[m].mult = mul, mul = 0;
&#125;
</code></pre>
<ol>
<li>接着，我们考虑如何进行$cdq$分治，同样是在计算左区间时，处理右区间的询问，不妨采用$two-pointers$，两个指针$i,j$分别指向左右两个区间，这时候我们以$b$为关键字进行比较，如果$d[i].b&lt;=d[j].b$，则将$d[i].c$插入权值$BIT$中，反之则在$BIT$中查询比$d[j].c$小的数的个数，作正贡献。在两个区间都扫完后，我们要考虑清空$BIT$，防止在接下来的递归回溯中被添加多次。</li>
</ol>
<pre><code class="lang-cpp">inline bool cmpy (Node x, Node y) &#123;
    return (x.b &lt; y.b) || (x.b == y.b &amp;&amp; x.c &lt; y.c);
&#125;
inline void cdq (int l, int r) &#123;
    if (l == r) return ;
    int mid = (l + r) &gt;&gt; 1;
    cdq(l, mid), cdq(mid + 1, r);
    int i = l;
    for (int j = mid + 1; j &lt;= r; ++j) &#123;
        while (d[i].b &lt;= d[j].b &amp;&amp; i &lt;= mid) update(d[i].c, d[i].mult), ++i;
        d[j].ans += query(d[j].c);
        //ans表示小于等于它的个数
    &#125;
    //清空BIT
    for (int k = l; k &lt; i; ++k)
        update(d[k].c, -d[k].mult);
    inplace_merge(&amp;d[l], &amp;d[mid + 1], &amp;d[r + 1], cmpy);
    //这个函数表示将区间[l,mid+1)和[mid+1,r+1)按照cmpy方法合并
&#125;
</code></pre>
<ol>
<li>计算答案。</li>
</ol>
<pre><code class="lang-cpp">for (int i = 1; i &lt;= m; ++i) ans[d[i].ans + d[i].mult - 1] += d[i].mult;
for (int i = 0; i &lt; n; ++i) printf(&quot;%d\n&quot;, ans[i]);
</code></pre>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using std::sort;
using std::inplace_merge;
typedef long long ll;

template&lt;typename T&gt;
inline void read (T &amp;x) &#123;
    char ch = getchar(); int flag = 1;
    while(ch != &#39;-&#39; &amp;&amp; (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;)) ch = getchar();
    if (ch == &#39;-&#39;) flag = -flag, ch = getchar();
    while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar();
    x *= flag;
&#125;

const int N = 1e5 + 10, K = 2e5 + 10;
int n, m, k, mul, ans[N], bit[K];
struct Node &#123;
    int a, b, c, mult, ans;
    inline void Init() &#123;
    read(a), read(b), read(c);
    &#125;
&#125; v[N], d[N];
inline bool cmpx (Node x, Node y) &#123;
    return (x.a &lt; y.a) || (x.a == y.a &amp;&amp; x.b &lt; y.b) || (x.a == y.a &amp;&amp; x.b == y.b &amp;&amp; x.c &lt; y.c);
&#125;
inline bool cmpy (Node x, Node y) &#123;
    return (x.b &lt; y.b) || (x.b == y.b &amp;&amp; x.c &lt; y.c);
&#125;

inline int lowbit (int x) &#123; return x &amp; (-x); &#125;
inline void update (int pos, int val) &#123;
    while (pos &lt;= k) bit[pos] += val, pos += lowbit(pos);
&#125;
inline int query (int pos) &#123;
    int val = 0;
    while (pos) val += bit[pos], pos -= lowbit(pos);
    return val;
&#125;

inline void cdq (int l, int r) &#123;
    if (l == r) return ;
    int mid = (l + r) &gt;&gt; 1;
    cdq(l, mid), cdq(mid + 1, r);
    int i = l;
    for (int j = mid + 1; j &lt;= r; ++j) &#123;
        while (d[i].b &lt;= d[j].b &amp;&amp; i &lt;= mid) update(d[i].c, d[i].mult), ++i;
        d[j].ans += query(d[j].c);
    &#125;
    for (int k = l; k &lt; i; ++k)   
        update(d[k].c, -d[k].mult);
    inplace_merge(&amp;d[l], &amp;d[mid + 1], &amp;d[r + 1], cmpy);
&#125;

int main () &#123;
    read(n), read(k);
    for (int i = 1; i &lt;= n; ++i) v[i].Init();
    sort(&amp;v[1], &amp;v[n + 1], cmpx);
    for (int i = 1; i &lt;= n; ++i) &#123;
        ++mul;
        if ((v[i].a ^ v[i + 1].a) || (v[i].b ^ v[i + 1].b) || (v[i].c ^ v[i + 1].c))
            d[++m] = v[i], d[m].mult = mul, mul = 0;
    &#125;
    cdq(1, m);
    for (int i = 1; i &lt;= m; ++i) ans[d[i].ans + d[i].mult - 1] += d[i].mult;
    for (int i = 0; i &lt; n; ++i) printf(&quot;%d\n&quot;, ans[i]);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title>树形背包学习笔记</title>
    <url>/2018/12/24/5/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="树形背包的一般形式"><a href="#树形背包的一般形式" class="headerlink" title="树形背包的一般形式"></a>树形背包的一般形式</h2><p>给定一棵有$n$个节点的点权树，要求你从中选出$m$个节点，使得这些选出的节点的点权和最大，一个节点能被选当且仅当其父亲节点被选中，根节点可以直接选。</p>
<h2 id="n-3-解法"><a href="#n-3-解法" class="headerlink" title="$n^3$解法"></a>$n^3$解法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>考虑设$f[u][i]$表示在$u$的子树中选择$i$个节点（包括它本身）的最大贡献，则可列出以下转移方程。</p>
<script type="math/tex; mode=display">
f[u][i]=max(f[u][j]+f[v][i-j]+d[v])\ [j=1...i-1]</script><p>其中$d[v]$表示点$v$的点权，$i-j$表示在子树$v$中选择$i-j$个节点。</p>
<p>由于遍历整棵树是$\Theta(n)$的，而选取$i$和$j$是$O(m^2)$的，所以整个程序的复杂度就是$O(nm^2)$的。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.org/problemnew/show/P2014">Luogu P2014 选课</a></p>
<p>这是一道树形背包的模板题，可以将题目转化为在$n+1$个节点中选$m+1$个节点。于是最后的答案就是$f[0][m+1]$。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using std::max;

const int N = 3e2 + 10, M = 3e2 + 10;
int n, m, f[N][N], s[N], son[N][N];

void dfs (int u) &#123;
    for (int i = 1; i &lt;= son[u][0]; ++i) &#123;
        int v = son[u][i]; dfs(v);
        for (int j = m + 1; j &gt;= 1; --j)
            for (int k = 0; k &lt; j; ++k)
                f[u][j] = max(f[u][j], f[u][j - k] + f[v][k]); 
    &#125;
&#125;

int main () &#123;
    scanf (&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1, fa; i &lt;= n; ++i) &#123;
        scanf (&quot;%d%d&quot;, &amp;fa, s + i);
        f[i][1] = s[i];
        son[fa][++son[fa][0]] = i;
    &#125;
    dfs(0);
    printf (&quot;%d\n&quot;, f[0][m + 1]);
    return 0;
&#125;
</code></pre>
<h2 id="n-2-解法"><a href="#n-2-解法" class="headerlink" title="$n^2$解法"></a>$n^2$解法</h2><p style="color: red;">警告：此算法可能思维难度较大，而且一般联赛不会考（但不排除作为压轴题考出），视情况阅读！</p>

<hr>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>显然，$n^3$算法的时间开销是很$Big$的，比如这道题：<a href="https://www.luogu.org/problemnew/show/P4322">洛谷 P4322 最佳团体</a>。</p>
<p>此题在$01$分数规划后采取树形背包$check$，但是，$nm^2log$的时间复杂度是不允许，考虑优化树形背包的$check$过程</p>
<p>首先，既然要优化，我们就得知道瓶颈在哪。瓶颈在于，我们是一边$dfs$一边更新的，由于要遍历子树，我们同时还要知道选择多少个节点，那么我们是否可以先跑一遍$dfs$处理出$dfs$序然后根据$dfs$序，来更新。</p>
<p>设$f[i][j]$为当前$dp$到$dfs$序为$i$的点，目前已经选了$j$个节点。则有转移方程（$d[i]$表示点权）：</p>
<blockquote>
<p>1.选取当前节点：</p>
</blockquote>
<script type="math/tex; mode=display">
f[i+1][j+1]=f[i][j]+d[i]</script><p>如果选了这个点，则在$dfs$序后一个节点要么是它的子节点，要么下一棵子树（则证明其没有子节点）。</p>
<blockquote>
<p>2.不选当前节点：</p>
</blockquote>
<script type="math/tex; mode=display">
f[nx[i]][j]=f[i][j]</script><p>其中$nx[i]$表示下一棵子树，因为你没选这个点，当然不能选择其子节点。</p>
<p>由于$dfs$序为$\Theta(n)$的，然后枚举$j$为$O(m)$的，所以总复杂度为$O(nmlog)$。</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>同样是<a href="https://www.luogu.org/problemnew/show/P2014">Luogu P2014 选课</a></p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using std::min;
typedef long long ll;

const int N = 3e2 + 10, M = 3e2 + 10, Inf = 1e9 + 7;
int n, m, d[N], s[N], dfn[N], son[N][N], time, f[N][N], nx[N];
inline void upt (int &amp;a, int b) &#123; if(a &lt; b) a = b; &#125;

void Init_dfs(int u) &#123;
    dfn[u] = time++;
    for (int i = 1; i &lt;= son[u][0]; ++i)
        Init_dfs(son[u][i]);
    nx[dfn[u]] = time;
&#125;

void Doit_dp() &#123;
    for (int i = 1; i &lt;= n; ++i)
        d[dfn[i]] = s[i];
    for (int i = 1; i &lt;= n + 1; ++i)
        for (int j = 0; j &lt;= m; ++j)
            f[i][j] = -Inf;
    for (int i = 0; i &lt;= n; ++i)
        for (int j = 0; j &lt;= min(i, m); ++j) &#123;
            upt(f[i + 1][j + 1], f[i][j] + d[i]);
            upt(f[nx[i]][j], f[i][j]);
        &#125;
&#125;

int main () &#123;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m); ++m;
    for (int i = 1, fa; i &lt;= n; ++i) &#123;
        scanf(&quot;%d%d&quot;, &amp;fa, s + i);
        son[fa][++son[fa][0]] = i;
    &#125;
    Init_dfs(0);//预处理dfs
    Doit_dp();//动态规划
    printf(&quot;%d\n&quot;, f[n + 1][m]);
    return 0;
&#125;
</code></pre>
<hr>
<p>之前我们提到的<a href="https://www.luogu.org/problemnew/show/P4322">洛谷 P4322 最佳团体</a>，就是用$01$分数规划&amp;树形背包来解决的</p>
<pre><code class="lang-cpp">// luogu-judger-enable-o2
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using std::min;
using std::max;

const int N = 3e3 + 10, inf = 1e9 + 7;
const double eps = 1e-5;
int n, K, s[N], p[N], son[N][N], dfn[N], time, nx[N];
int from[N], to[N], nxt[N], cnt;//Edges
double f[N][N], d[N];

inline void addEdge (int u, int v) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], from[u] = cnt;
&#125;

inline void upt(double &amp;a, double b) &#123;
    if (a &lt; b) a = b;
&#125;

void dfs (int u) &#123;
    dfn[u] = time++;
    for (int i = from[u]; i; i = nxt[i]) dfs(to[i]);
    nx[dfn[u]] = time;
&#125;

inline bool check (double k) &#123;
    for (int i = 1; i &lt;= n; ++i) 
        d[dfn[i]] = p[i] - k * s[i];
    for (int i = 1; i &lt;= n + 1; ++i)
        for (int j = 0; j &lt;= K; ++j)
            f[i][j] = -inf;
    for (int i = 0; i &lt;= n; ++i)
        for (int j = 0; j &lt;= min(i, K); ++j) &#123;
            upt(f[i + 1][j + 1], f[i][j] + d[i]);
            upt(f[nx[i]][j], f[i][j]);
        &#125;
    return f[n + 1][K] &gt;= eps;
&#125;

int main () &#123;
    scanf(&quot;%d%d&quot;, &amp;K, &amp;n); ++K;
    for (int i = 1, fa; i &lt;= n; ++i)  &#123;
        scanf(&quot;%d%d%d&quot;, s + i, p + i, &amp;fa);
        addEdge(fa, i);
    &#125;
    dfs(0);
    double l = 0, r = 10000, ans;
    while (r - l &gt;= eps) &#123;
        double mid = (l + r) * 0.5;
        if (check(mid)) ans = mid, l = mid + eps;
        else r = mid - eps;
    &#125;
    printf (&quot;%.3lf\n&quot;, ans);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>[C++]动态规划-树形DP</tag>
        <tag>[C++]动态规划-背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title>逆序对的两种求法（复习）</title>
    <url>/2018/12/24/4/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h2><p>对于一个数列$a_1…a_n$，定义一有序对$(i,j)$当且仅当$i<j$且$a_i>a_j$为逆序对。接着我们来考虑怎么求</p>
<h2 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="*1. 归并排序"></a>*1. 归并排序</h2><p>回顾归并排序的过程，将当且的数列$[l,r]$分成两个长度相等的部分$[l,mid]$和$[mid+1,r]$，分治下去排序，每次合并的代价是区间的长度，所以得到时间复杂度为：</p>
<script type="math/tex; mode=display">
T(n)=2T(\frac{n}{2})+f(n)</script><p>根据$master$定理可知时间复杂度为$\Theta(nlog_2n)$</p>
<pre><code class="lang-cpp">int MergeSort (int l, int r) &#123;
    if (l == r) return ;
    int mid = (l + r) &gt;&gt; 1;
    MergeSort(l, mid), MergeSort(mid + 1, r);
    int i = l, j = mid + 1, t = l;
    while(i &lt;= mid &amp;&amp; j &lt;= r)
        if (a[i] &lt;= a[j]) b[t++] = a[i++];
        else b[t++] = a[j++];
    while(i &lt;= mid) b[t++] = a[i++]; while(j &lt;= r) b[t++] = a[j++];
    for(int k = l; k &lt;= r; ++k) a[k] = b[k];
&#125;
</code></pre>
<p>等一下！你讲了这么久，到底怎么求逆序对？？？</p>
<hr>
<p>我们截取一段代码：</p>
<pre><code class="lang-cpp">else b[t++] = a[j++]
</code></pre>
<p>由于归并排序是将一个区间分成左右两端，故右边一段中的任何一个元素一定在左边一段中任何一个元素之后，这种性质同样用于分治处理，所以，当我们加入一个右区间元素时，此时左区间中剩下没加入的元素一定就比它大，所以改写一下：</p>
<pre><code class="lang-cpp">else b[t++] = a[j++], ans += mid - i + 1;//ans为逆序对个数
</code></pre>
<p>由于分治的性质，所以每个逆序对都会不重不漏地选到。</p>
<h2 id="2-树状数组"><a href="#2-树状数组" class="headerlink" title="*2. 树状数组"></a>*2. 树状数组</h2><p>$BIT$作为一种巧妙的数据结构，其利用了一种类似于前缀和的思想。通过权值$BIT$来求解逆序对。</p>
<p>其算法核心在于，先确立$a_j&lt;a_i$的大小关系，按从小到大插入其下标，通过计算前缀和的方式来求解。</p>
<p>比如我们现在有一个数$a_i$，我们向$BIT$中插入其下标$i$后计算当前小于等于其下标的数的个数$tot$，则答案就是$i-tot$。</p>
<p>因为此时$a_i&gt;a_j$($j$为之前已插入的数的下标)，所以$i-tot$即位置在$i$之后的个数就是当前$i$ 对答案产生的贡献（满足$a_j<a_i\&j>i$）。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
typedef long long ll;
using std::sort;

const ll N = 5e5 + 10;
ll n, a[N], b[N], c[N], ans;

inline bool cmp (ll x, ll y) &#123; return a[x] &lt; a[y] || (a[x] == a[y] &amp;&amp; x &lt; y); &#125;
inline ll lowbit (ll x) &#123; return x &amp; (-x); &#125;
inline void add (ll x, ll y) &#123; for (; x &lt;= n; x += lowbit(x)) c[x] += y; &#125;
inline ll query (ll x) &#123; ll y = 0; for (; x &gt; 0; x -= lowbit(x)) y += c[x]; return y; &#125;

int main () &#123;
    scanf (&quot;%lld&quot;, &amp;n);
    for (ll i = 1; i &lt;= n; ++i) scanf (&quot;%lld&quot;, a + i), b[i] = i;
    sort (b + 1, b + n + 1, cmp);
    for (ll i = 1; i &lt;= n; ++i) add(b[i], 1). ans += i - query (b[i]);
    printf (&quot;%lld\n&quot;, ans);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>[C++]数据结构-树状数组</tag>
        <tag>[C++]数据结构-cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces888E Maximum Subsequence（折半枚举+two-pointers）</title>
    <url>/2018/12/24/3/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个包含$n$个数的序列$a$，在其中任选若干个数，使得他们的和对$m$取模后最大。（$n\leq 35$）</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然，$2^n$的暴枚是不现实的…，于是我们想到了折半枚举，分成两部分暴枚，然后考虑合并，合并的时候用two-pointers思想扫一遍就行了。</p>
<p>其实这是一道折半枚举+Two-Pointers的很好的练手题</p>
<pre><code class="lang-cpp">//最近CodeForces有点萎，可能会JudgementError，但已经评测过了，能AC，多交几次应该可以
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using std::max;
using std::sort;

const int N = 40, K = 19;
int n, m, k, ans, totx, toty;
long long a[N], x[1 &lt;&lt; K], y[1 &lt;&lt; K];

template &lt;typename T&gt;
inline void read(T &amp;x) &#123;
    x = 0; char ch = getchar();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) ch = getchar();
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar();
&#125;

void dfsx (int i, long long sum) &#123;
    if (i &gt; k) &#123; x[++totx] = sum % m; return ; &#125;
    dfsx (i + 1, sum + a[i]);
    dfsx (i + 1, sum);
&#125;

void dfsy (int i, long long sum) &#123;
    if (i &gt; n) &#123; y[++toty] = sum % m; return ; &#125;
    dfsy (i + 1, sum + a[i]);
    dfsy (i + 1, sum);
&#125;

int main () &#123;
    read(n), read(m), k = n &gt;&gt; 1;
    for (int i = 1; i &lt;= n; ++i) read(a[i]);
    dfsx(1, 0), dfsy(k + 1, 0);
    sort(&amp;x[1], &amp;x[totx + 1]), sort(&amp;y[1], &amp;y[toty + 1]);
    int l = 1, r = toty;
    while (l &lt;= totx) &#123;
        while (r &amp;&amp; x[l] + y[r] &gt;= m) --r; if(!r) break;
        ans = max(ans, int((x[l] + y[r]) % m)), ++l;
    &#125;
    printf (&quot;%d\n&quot;, ans);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]搜索优化-折半枚举,meeting in the middle</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOJ11469 Subset（折半枚举）</title>
    <url>/2018/12/24/2/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个集合，有多少个非空子集,能划分成和相等的两份。$n\leq 20$</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>看到这个题，首先能想到的是$3^n$的暴力枚举，枚举当前元素是放入左边还是放入右边或者根本不放，但是显然是不可取的，看到$n$只有20，考虑折半搜索，将集合分成两部分，每个部分$3^{\frac{n}{2}}$枚举。</p>
<p>接着考虑如何合并，在枚举时计一个$delta$表示此时左边和右边的差值，这样在右半部分每一次枚举完后我们可以直接在左半部分查找是否存在一个$delta$相等，如果相等，则两个集合的并集满足条件</p>
<pre><code class="lang-cpp">#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
typedef long long ll;

template &lt;typename T&gt;
inline void read(T &amp;x) &#123;
    x = 0; char ch = getchar();
    while (ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) ch = getchar();
    while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) x = x * 10 + ch - &#39;0&#39;, ch = getchar();
&#125;

const int N = 21;
int n, m, a[N], cnt, ans;
std::map &lt;int, int&gt; Ma;
std::vector &lt;int&gt; S[1 &lt;&lt; N];
bool ok[1 &lt;&lt; N];

void dfs1(int i, int s, int d) &#123;
    if (i &gt; m) &#123;
    if (Ma.find(d) == Ma.end()) Ma[d] = ++cnt;
    int index = Ma[d];
    //记录delta，由于可能存在多个相等的delta，开一个vector记下它是哪个集合（状态压缩）
    S[index].push_back(s);
    return ;
    &#125;
    dfs1(i + 1, s, d);
    dfs1(i + 1, s | (1 &lt;&lt; i), d + a[i]);
    dfs1(i + 1, s | (1 &lt;&lt; i), d - a[i]);
&#125;

void dfs2(int i, int s, int d) &#123;
    if (i &gt; n) &#123;
    if (Ma.find(d) == Ma.end()) return ;
    int index = Ma[d];
    std::vector&lt;int&gt;::iterator it;
    //直接查询然后置他们的并集为真即可
    for (it = S[index].begin(); it != S[index].end(); ++it)
        ok[*it | s] = true;
    return ;
    &#125;
    dfs2(i + 1, s, d);
    dfs2(i + 1, s | (1 &lt;&lt; i), d + a[i]);
    dfs2(i + 1, s | (1 &lt;&lt; i), d - a[i]);
&#125;

int main () &#123;
    read(n); m = n &gt;&gt; 1;
    for(int i = 1; i &lt;= n; ++i) read(a[i]);
    dfs1(1, 0, 0);
    dfs2(m + 1, 0, 0);
    for(int i = (1 &lt;&lt; (n + 1)) - 1; i &gt;= 1; --i)
    ans += ok[i];
    printf(&quot;%d\n&quot;, ans);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]搜索优化-折半枚举,meeting in the middle</tag>
      </tags>
  </entry>
  <entry>
    <title>倍增LCA学习笔记</title>
    <url>/2018/12/24/1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    “倍增”，作为一种二进制拆分思想，广泛用于各中算法，如$ST$表，求解$LCA$等等…今天，我们仅讨论用该思想来求解树上两个节点的$LCA$（最近公共祖先）<br><span id="more"></span></p>
<h3 id="“倍增”是什么东西？"><a href="#“倍增”是什么东西？" class="headerlink" title="“倍增”是什么东西？"></a>“倍增”是什么东西？</h3><p>​    倍增就是“成倍增加”的意思，比如$1$倍增后变成了$2$，$2$倍增后就变成了$4$，$4$变成$8$，以此类推…</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="一直向上LCA"><a href="#一直向上LCA" class="headerlink" title="一直向上LCA"></a>一直向上LCA</h3><p>​    在讲真正的倍增之前，我们先来说说最朴素的$LCA$，对于需要求解的两个点$(x,y)$，我们最先能想到的方法就是两个点先到达同一深度，然后一直往上跳父亲，知道两个点跳到同一个点上，这个点就是$LCA$。</p>
<pre><code class="lang-cpp">int LCA (int x, int y) &#123;
    if (depth[x] &lt; depth[y]) swap(x, y);
    while(depth[x] != depth[y]) x = fa[x];
    while(x != y) x = fa[x], y = fa[y];
    return x;
&#125;
</code></pre>
<p>​    不难发现，这种算法的时间开销很大，我们想办法来优化它。</p>
<h3 id="倍增LCA"><a href="#倍增LCA" class="headerlink" title="倍增LCA"></a>倍增LCA</h3><p>​    就如同$ST$表一样，我们不妨设$f[i][j]$表示树上编号为$i$的节点向上跳$2^j$个节点后所达到的节点，如同$ST$表的预处理，我们很容易发现如何预处理出这个$f$数组：</p>
<pre><code class="lang-cpp">f[i][j] = f[f[i][j-1]][j-1];
</code></pre>
<p>​    显然，$i$往上跳$2^{j-1}$次之后再跳$2^{j-1}$次之后就相当于$i$往上跳$2^j$次，我们可以借此来优化，利用二进制优化背包的思想那样，将跳的次数二进制拆分。</p>
<p>​    于是，我们改写一下之前的代码</p>
<pre><code class="lang-cpp">int LCA (int x, int y) &#123;
    if (depth[x] &lt; depth[y]) swap(x, y);
    for (int i = LogN; i &gt; 0; --i)
        if (depth[f[x][i]] &gt;= depth[y])
            x = f[x][i];
    if (x == y) return x;
    for (int i = LogN; i &gt; 0; --i)
        if (f[x][i] != f[y][i])
            x = f[x][i], y = f[y][i];
    return f[x][0];
&#125;
</code></pre>
<p>​    这样一来，速度就快很多了，由原来的$O(Depth)$变成了现在的$O(log_2(Depth))$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
typedef int ll;

const ll N = 5e5 + 10, M = 5e5 + 10, LogN = 25;
ll n, m, s, depth[N], f[N][LogN], a, b, c;
ll from[N], to[M &lt;&lt; 1], nxt[M &lt;&lt; 1], cnt, tmp, Log[N];
inline void swap (ll &amp;a, ll &amp;b) &#123;tmp = a, a = b, b = tmp;&#125;
//链式前向星加边
void addEdge (ll u, ll v) &#123;
    to[++cnt] = v, nxt[cnt] = from[u], from[u] = cnt;
&#125;
//计算深度&amp;计算祖先
void doit (ll u, ll fa) &#123;
    depth[u] = depth[fa] + 1;
    for (register ll i = 1; i &lt;= Log[n]; ++i) &#123;
        if ((1 &lt;&lt; i) &gt;= depth[u]) break;
        f[u][i] =  f[f[u][i - 1]][i - 1];
    &#125;
    for (register ll i = from[u]; i; i = nxt[i]) &#123;
        ll v = to[i];
        if (v == fa) continue;
        f[v][0] = u;
        doit (v, u);
    &#125;
&#125;
//计算LCA
inline ll LCA (ll x, ll y) &#123;
    if (depth[x] &lt; depth[y]) swap(x, y);
    //我们默认x为更深的那个点
    for (register ll i = 0; i &lt;= Log[n]; ++i)
        if (depth[f[x][i]] &gt;= depth[y])
            x = f[x][i];
    //将x跳到和y同一深度上
    if (x == y) return x;
    for (register ll i = Log[n]; i &gt;= 0; --i)
        if (f[x][i] != f[y][i])
            x = f[x][i], y = f[y][i];
    //一起向上跳
    return f[x][0];
    //不难看出，此时两个点均在其LCA的下方，往上跳一次即可
&#125;

int main () &#123;
    scanf (&quot;%d%d&quot;, &amp;n, &amp;m);//n节点数 m询问次数
    Log[0] = -1;
    for (register ll i = 1, u, v; i &lt; n; ++i) &#123;
        scanf (&quot;%d%d&quot;, &amp;u, &amp;v);
        addEdge (u, v); addEdge(v, u);
        Log[i] = Log[i &gt;&gt; 1] + 1;
    &#125;
    Log[n] = Log[n &gt;&gt; 1] + 1;
    doit (1, 0);
    while (m--) &#123;
        scanf (&quot;%d%d&quot;, &amp;a, &amp;b);
        printf (&quot;%d\n&quot;, LCA(a, b)));
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>[C++]树论-LCA,最近公共祖先</tag>
        <tag>[C++]算法思想-倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>基于单调队列的多重背包优化</title>
    <url>/2018/09/19/MutilPack-Queue/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><p>​    多重背包，想必看到这篇博文的人应该都知道了，这里仅仅列出伪代码（$n$为物品个数，$m$为背包容积）</p>
<pre><code class="lang-cpp">for i := 1 to N
    for j := 0 to M
        for k := 0 to c[i]
            f[i][j] = max(f[i - 1][j - k * v[i]] + k * w[i])
</code></pre>
<p>​    显然，这种算法的复杂度是很不可取的，于是我们来考虑优化</p>
<h2 id="1-2-优化方式"><a href="#1-2-优化方式" class="headerlink" title="1.2 优化方式"></a>1.2 优化方式</h2><p>​    设$c,v,w$分别为当前物品的个数，体积，价值，根据原始转移方程可知，$f<em>i$一定是由$f</em>{i-1}$转移而来，所以$c,v,w$不用开数组（有的$OJ$竟然会卡空间…），为了方便说明，以下设数组$g$表示数组$f_{i-1}$，于是方程简化为：</p>
<pre><code class="lang-cpp">f[j] = max(g[j - k * v] + k * w) //0≤k≤c
</code></pre>
<p>​    显然，就算不简化，我们也能看出：$f<em>j$只从$f</em>{j-v<em>i},f</em>{j-v<em>i\times 2}…f</em>{j-v_i\times c}$转移过来，且对于每一个这其中的$j$，都有如下性质：它们模上$v$后的余数相同，于是我们将其模$v$后的余数拎出来考虑，循环可以这样写：</p>
<pre><code class="lang-cpp">for i := 1 to N
    for j := 0 to v - 1
        ...
</code></pre>
<p>​    接下来呢，就要枚举系数$k$了</p>
<pre><code class="lang-cpp">for (k = 0; k * v + j &lt;= M; ++k)
</code></pre>
<p>​    你不觉得枚举系数很麻烦吗？这样就好了</p>
<pre><code class="lang-cpp">for (k = j; k &lt;= M; k += v)
</code></pre>
<p>​    接下来来看转移方程，根据之前得出的转移方程，显然我们是要找到在一个长度为$c$的区间内最大的$g[j - k \times v] + k\times w$，可以用单调队列来存储，于是又有</p>
<pre><code class="lang-cpp">while (l &lt;= r &amp;&amp; (k - q[l]) / v &gt;= c) ++l;
while (l &lt;= r &amp;&amp; f[i - 1][k] - f[i - 1][q[r]] &gt;= (k - q[r]) / v * w) --r;
q[++r] = k; 
f[i][k] = f[i - 1][q[l]] + (k - q[l]) / v * w;
</code></pre>
<ul>
<li>这里的$(k-q_i)/v$代表两个数的系数相差多少，$+1$后则代表所跨区间的长度,这里的$(k - q[l]) / v \geq c$用于防止区间长度大于$c$，相当于$(k - q[l]) / v + 1 &gt; c$，不满足条件则弹出队首元素。</li>
<li>当在队列中插入新元素时，需有$g[k]+k/v\times w \geq g[q[r]]+q[r]/v\times w$，这是根据单调队列所存储元素的定义得出的，移项后得$g[k]-g[q[r]]&gt;=(k-q[r])/v\times w$，巧妙地避免了余数的问题。</li>
<li>我们只插入$k$就好了，不然不方便$\Delta w$的计算。</li>
<li>这里取队首再加上$\Delta w=(k-q[l])/v\times w$就好了</li>
</ul>
<h2 id="1-3-代码"><a href="#1-3-代码" class="headerlink" title="1.3 代码"></a>1.3 代码</h2><pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
using namespace std;

const int N = 1e3 + 10, M = 1e4 + 10;
int n, m, f[N][M], v, w, c, q[M], l, r, ans;

int main () &#123;
    scanf (&quot;%d%d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i) &#123;
        scanf (&quot;%d%d%d&quot;, &amp;c, &amp;v, &amp;w);
        c = min (c, m / v);
        for (int j = 0; j &lt; v; ++j) &#123;
                l = 1; r = 0;
            for (int k = j; k &lt;= m; k += v) &#123;
                while (l &lt;= r &amp;&amp; (k - q[l]) / v &gt;= c) ++l;
                while (l &lt;= r &amp;&amp; f[i - 1][k] - f[i - 1][q[r]] &gt;= (k - q[r]) / v * w) --r;
                q[++r] = k;
                f[i][k] = f[i - 1][q[l]] + (k - q[l]) / v * w;
            &#125;
        &#125;
    &#125;
    for (int i = 1; i &lt;= m; ++i)
        ans = max (ans, f[n][i]);
    printf (&quot;%d\n&quot;, ans);
    return 0;
&#125;
</code></pre>
<h2 id="1-4-注意"><a href="#1-4-注意" class="headerlink" title="1.4 注意"></a>1.4 注意</h2><ol>
<li>单调队列初始化为$l=1,r=0$，且在循环$j$内初始化</li>
<li>单调队列长度开到$M$，因为有可能出现$v=1$的情况</li>
<li>最后答案不一定存在$f_{n,m}​$里面，要在$1…m​$扫一遍</li>
<li>一定要记得$c=min(c,m/v)$，为了防止背包溢出</li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>[C++]动态规划-背包DP</tag>
        <tag>[C++]数据结构-单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ3274 Circle</title>
    <url>/2018/08/19/Problem-BZOJ-3274/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>经过打表发现，所填的数在区间$[k,k+15]$之间，所以可以暴枚…<br>为了节省版面，给出$n=5$和$n=6$的情况，其它情况类似</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
typedef long long ll;

ll a[20], n, ans, add, reans[1000010][10], p[1000010], m, k;
bool b[1000010];

bool judge() &#123;
    for (register ll i = n + 1; i &lt;= n * 2; ++i)
        a[i] = a[i - n];
    for (register ll i = 1; i &lt;= n &lt;&lt; 1; ++i)
        p[i] = p[i - 1] + a[i];
    for (register ll i = 1; i &lt;= p[n &lt;&lt; 1]; ++i)
        b[i] = 0;
    for (register ll i = 1; i &lt;= n; ++i)
        for (register ll j = i; j &lt;= i + n - 1; ++j)
            b[p[j] - p[i - 1]] = true;
    ll i = m;
    while (b[i]) i++;
    i--;
    if(i &gt; ans) &#123;
        add = 0, ans = i;
        return true;
    &#125;
    return i == ans;
&#125;

int main() &#123;
    scanf (&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;k);
    if(n==5) &#123;
        for(a[1] = k; a[1] &lt;= m; ++a[1])
            for(a[2] = a[1]; a[2] &lt;= k + 15; ++a[2])
                for(a[3] = a[1]; a[3] &lt;= k + 15; ++a[3])
                    for(a[4] = a[1]; a[4] &lt;= k + 15; ++a[4])
                        for(a[5] = a[1]; a[5] &lt;= k + 15; ++a[5])
                            if(judge())
                                reans[++add][0]=a[1], reans[add][1]=a[2], reans[add][2]=a[3], reans[add][3]=a[4], reans[add][4]=a[5];
    &#125; else &#123;
        for(a[1] = k; a[1] &lt;= m; ++a[1])
            for(a[2] = a[1]; a[2] &lt;= k + 15; ++a[2])
                for(a[3] = a[1]; a[3] &lt;= k + 15; ++a[3])
                    for(a[4] = a[1]; a[4] &lt;= k + 15; ++a[4])
                        for(a[5] = a[1]; a[5] &lt;= k + 15; ++a[5])
                            for(a[6] = a[1]; a[6] &lt;= k + 15; ++a[6])
                                if(judge())
                                    reans[++add][0] = a[1], reans[add][1] = a[2], reans[add][2] = a[3], reans[add][3] = a[4], reans[add][4] = a[5], reans[add][5] = a[6];
    &#125;
    printf(&quot;%lld\n&quot;,ans);
    for(register ll i = 1; i &lt;= add; ++i) &#123;
        for(register ll j = 0; j &lt; n; ++j)
            printf(&quot;%d &quot;, reans[i][j]);
        puts(&quot;&quot;);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]玄学算法</tag>
      </tags>
  </entry>
  <entry>
    <title>USACO13NOV-No Change</title>
    <url>/2018/08/19/Problem-USACO13NOV/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚看到这道题$k\leq 16$的范围时我以为是暴力枚举…<br>于是就高高兴兴敲了一个暴枚+贪心骗分…<br>最后觉得骗分不实在，于是就改成暴枚+全排列+二分查找了…</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>其实可以用DP来做，不过会MLE，怎么办呢？<br>这时我们发现: $k\leq 16$ 于是可以压硬币的状态！<br>于是就变成了状态压缩DP！<br>转移方程:<br>设$dp<em>i$表示我们选硬币集合 i（状压）从一号物品开始最多能买的物品数。<br>于是有：$dp_i=max(dp_i,dp</em>{subset(i)}+coin)$<br>这里的coin表示选了当前这块硬币后又能买多少东西！<br>怎么处理coin呢？——用二分查找啊，在原基础上利用前缀和进行二分查找…（前缀和单调递增啊）<br>当然，你也可以用尺取预先处理（空间换时间）</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using std::upper_bound;
typedef long long ll;

inline ll max (ll a, ll b) &#123;return a &gt; b ? a : b;&#125;
const ll K = 16, N = 1e5 + 10;
ll k, n, ce[K], co[N], sum[N], cnt, ans = -1, dp[70000];

//计算当前所剩钱数 
inline ll num (ll i) &#123;
    ll val = cnt;
    for (register ll j = 0; j &lt; k; ++j)
        if (i &amp; (1 &lt;&lt; j)) val -= ce[j];
    return val;
&#125;

int main () &#123;
    scanf (&quot;%lld%lld&quot;, &amp;k, &amp;n);
    for (register ll i = 0; i &lt; k; ++i) &#123;
        scanf (&quot;%lld&quot;, ce + i);
        cnt += ce[i];
    &#125;
    for (register ll i = 1; i &lt;= n; ++i) &#123;
        scanf (&quot;%lld&quot;, co + i);
        sum[i] = sum[i - 1] + co[i];
    &#125;
    for (register ll i = 1; i &lt; (1 &lt;&lt; k); ++i) 
        for (register ll j = 0; j &lt; k; ++j) 
            if (i &amp; (1 &lt;&lt; j)) &#123;
                ll tmp = i ^ (1 &lt;&lt; j);
                tmp = upper_bound(sum + 1, sum + n + 1, sum[dp[tmp]] + ce[j]) - sum - 1;
                dp[i] = max(dp[i], tmp);
            &#125;
    for (register ll i = 1; i &lt; (1 &lt;&lt; k); ++i)
        if (dp[i] == n)
            ans = max (ans, num(i));
    printf (&quot;%lld\n&quot;, ans);
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]动态规划-状态压缩DP</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1014 Dividing</title>
    <url>/2018/08/19/Problem-POJ-1014/</url>
    <content><![CDATA[<p>这里是简介<br><span id="more"></span></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>简单分析题目可以看出这是一道多重背包题目，不妨将价值看成重量，于是有我们要凑出的重量为：$w=\frac{\sum_{i=1}^{6}{w[i]*i}}{2}$<br>但是当前复杂度会超时…所以我们要优化时间复杂度<br>因为当我们做多重背包时，我们是将它转化成01背包来做的（即选1件-N件）<br>所以我们可以采用二进制拆分的方式进行优化：</p>
<blockquote>
<p>不妨设当前有7件价值为1的物品。<br>7(10) = 111(2)，将7分成1件，2件和4件<br>选一件+选两件=选三件，以此类推<br>于是就从多重背包变成了裸的01背包！</p>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
typedef long long ll;

const ll N = 6e4 + 10, M = 2e4 + 10;
ll n[7], sum, yq, t, w[M], cnt;
bool dp[N];

int main () &#123;
    while (true) &#123;
        memset (dp, false, sizeof dp);
        cnt = 0, sum = 0, ++t;
        for (register ll i = 1; i &lt;= 6; ++i) &#123;
            scanf (&quot;%lld&quot;, n + i);
            sum  += n[i] * i;
        &#125;
        if (!sum) return 0;
        //特判，当和为奇数时，显然不能分 
        if (sum &amp; 1) &#123;
            printf (&quot;Collection #%lld:\n&quot;, t); 
            puts(&quot;Can&#39;t be divided.&quot; &quot;\n&quot;);
            continue;
        &#125;    
        yq = sum &gt;&gt; 1, dp[0] = true;
        //二进制拆分 
        for (register ll i = 1; i &lt;= 6; ++i) &#123;
            ll k = 1, tot = n[i];
            while (k &lt;= tot) &#123;
                w[++cnt] = k * i;
                tot -= k, k &lt;&lt;= 1;
            &#125;
            if (tot) w[++cnt] = tot * i;
        &#125;
        //01背包 
        for (register ll i = 1; i &lt;= cnt; ++i)
            for (register ll j = yq; j &gt;= w[i]; --j)
                dp[j] |= dp[j - w[i]];
        printf (&quot;Collection #%lld:\n&quot;, t); 
        puts (dp[yq] ? &quot;Can be divided.\n&quot; : &quot;Can&#39;t be divided.\n&quot;);
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>[C++]动态规划-背包DP</tag>
        <tag>[C++]算法思想-二进制拆分</tag>
      </tags>
  </entry>
  <entry>
    <title>刀剑神域第21册先导吐槽</title>
    <url>/2018/08/01/SAO-21/</url>
    <content><![CDATA[<p>前几天在SAO吧里看到了SAO21的先导（去年12月份发的），再看看今天的日期…<br>禁不住感慨一波川原砾的魔幻打字速度。</p>
<p>既然这样，在没出正式版前，先发一波先（tǔ）评（cáo）。</p>
<span id="more"></span>
<h1 id="EP0-先导链接"><a href="#EP0-先导链接" class="headerlink" title="EP0 - 先导链接"></a>EP0 - 先导链接</h1><p><a href="https://tieba.baidu.com/p/5473153615">[自翻][川原 砾][Sword Art Online][Unital Ring][+a]</a></p>
<p>感谢汉化组！</p>
<h1 id="EP1-标题"><a href="#EP1-标题" class="headerlink" title="EP1 - 标题"></a>EP1 - 标题</h1><p>首先是标题:本章的标题叫做[Unital Ring]，暂时没有本土化翻译，<br>所以不翻了（就我这垃圾外语水平），还是[Moon Cradle - 月之摇篮]更好翻译</p>
<h1 id="EP2-设定"><a href="#EP2-设定" class="headerlink" title="EP2 - 设定"></a>EP2 - 设定</h1><p>PS : 以下内容为日文维基中[可能]和本作有关的设定</p>
<p>出自[Ordinal Scale - 序列之争]部分，有可能在文库本内有所改动。<br>这里的OS设定是指游戏中的设定，与电影还是有一点关系的</p>
<p><img src="https://s1.ax1x.com/2018/08/01/PwXibq.md.png" alt="PwXibq.md.png"></p>
<p>从文中，我们可以看出，这一次设定比ALO篇要容易，只有三种职业，<br>而且没有魔（膜）法师，因为是借用序列之争的设定，所以川原老爷子自然把序列之争的Augma搬了过来，<br>Augma就是那个目前造不出来的高级AR【看过的总该有点印象】。<br>重点是，该篇的设定和SAO一样，是没有魔法师的，回血只能靠道具</p>
<p><img src="https://s1.ax1x.com/2018/08/01/PwXkV0.md.png" alt="PwXkV0.md.png"></p>
<p>[对DBA游击队员]应该就类似于玩家…而[适合者]应该就类似于对应完全潜行适应者<br>不断工作会获得更高收入这点…</p>
<blockquote>
<p>贪玩蓝月，点一下，玩一年，装备回收还可兑换现金</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2018/08/01/PwXeGF.md.png" alt="PwXeGF.md.png"></p>
<p>这没什么好分（tǔ）析（cáo）的，总而言之就是类似于联合国和联合国维和部队吧</p>
<p><img src="https://s1.ax1x.com/2018/08/01/PwXm24.md.png" alt="PwXm24.md.png"></p>
<p>这里讲了一些主要派系，[Aggressor]有点类似于[SAO]中的“微笑棺木”，但又不能说完全像。</p>
<p>[Arbiter]有点类似于【三体】里面的拯救派…比较苟的一个派系</p>
<p>[Unital]就是本篇的对立方了【应该吧】，就有点像三体人…</p>
<p><img src="https://s1.ax1x.com/2018/08/01/PwXnxJ.png" alt="PwXnxJ.png"></p>
<p>[DBA]就是本篇的主要敌人了，竟然拿动物为蓝本…<br>而[D-Tuner]与[Augma]，[Blade Type]与SAO中的刀剑，<br>[Gun Type]与GGO中的枪械，[Wand Type]与ALO中的法杖也是相类似的<br>说好的没有魔法师呢…</p>
<p><img src="https://s1.ax1x.com/2018/08/01/PwXKM9.md.png" alt="PwXKM9.md.png"></p>
<p>怎么说呢，就是传统RPG里面的原材料吧…</p>
<h1 id="EP3-原文"><a href="#EP3-原文" class="headerlink" title="EP3 - 原文"></a>EP3 - 原文</h1><blockquote>
<p>在分析原文之前，我花了一些时间把18章又看了一遍，发现了一些东西：</p>
<ul>
<li>桐人的养父叫桐谷峰嵩，养母叫桐谷翠</li>
<li>桐人在underworld里有一个复制体（复制星王），但亚丝娜没有，复制星王在21章中可能很重要</li>
<li>茅场晶彦又死了一次，但貌似还没死透[阴魂不散的男人]</li>
</ul>
</blockquote>
<p><img src="https://s1.ax1x.com/2018/08/02/P0pCMF.md.png" alt="P0pCMF.md.png"></p>
<p>首先，这是一段对话，应该是茅场和星王的对话，推测如下:</p>
<blockquote>
<ul>
<li>“原本应该和肉体一起消失不见的感情正在复活了”可以看出说话的人已经死了，但没有死透（有的人死了，他还活着）</li>
<li>另一个种子应该就是[The Seed]，原本的种子就是生成艾恩葛朗特的那个</li>
<li>“托付给他”，在SAO篇的结尾，茅场给了桐人[The Seed]，以及另一方最初说“我”，可以看出就是星王（桐人复制体）和茅场的对话</li>
<li>在第18章里面，星王最后是活了200多年，所以星王说“大出不知多少岁”这种话。而且星王还和比嘉健说要去找茅场（当时比嘉还认为茅场死了）</li>
</ul>
</blockquote>
<p>这里的[她]应该指的是结衣[唯]，因为在SAO篇中有提到，结衣是被茅场制作出来后抛弃的，<br>但并不太可能是爱丽丝，因为爱丽丝暂时没有展现出控制电脑的能力，而结衣是有的（详见序列之争）</p>
<p>[连接体]，指的应该就是连接到[The Seed]的各个服务器（例如GGO）,[统一]指的就是所有服务器归结到同一个服务器上吧…</p>
<p><img src="https://s1.ax1x.com/2018/08/02/P0pJit.png" alt="P0pJit.png"></p>
<ul>
<li>首先我最想吐槽的，是桐人亲生父母的名字，个人觉得不怎么好听…但[鸣人]应该就是官方玩梗了，从上文可以看出，桐人的父母是遭遇车祸而死的。</li>
<li>“翠阿姨”就是之前提到过的桐人的养母“桐谷翠”</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/08/02/P0pwLQ.png" alt="P0pwLQ.png"></p>
<ul>
<li>“唯”就是结衣[Yui]的另一种翻译，这一段就是官方搞事</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/08/02/P0AUtH.png" alt="P0AUtH.png"></p>
<ul>
<li>这个所谓[视听觉双向通信探测仪]应该就是动画里面那个在桐人肩上的类似于摄像头的东西。</li>
<li>[Augma]就是序列之争里那个耳机式的AR，[AmuSphere]就是ALO篇的VR</li>
<li>桐人老爷你怕是忘了你的女朋友被这个[Augma]害的多惨</li>
<li>MR[混合现实]有点类似于AR，简单来说，就是AR和VR的结合</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/08/02/P0EXdS.png" alt="P0EXdS.png"></p>
<ul>
<li>小唯是桐人的对结衣的爱称</li>
<li>这个纯白色高塔应该指的就是UnderWorld里公理教会（现在属于人界统一会议）的“中央大教堂”</li>
<li>因为桐人在回归RealWorld后让比嘉健消除了他在UnderWorld中加速时200年的记忆，但并没有消除这之前的，<br>所以桐人没有忘记之前在UnderWorld中的一些事情，所以桐人才会有（应该要消除所有记忆）这类的话。</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/08/02/P0VEoF.png" alt="P0VEoF.png"></p>
<ul>
<li>从这里可以看出川原老贼是直接把序列之争当做正篇了…而且两件事时隔半年。</li>
<li>说好的OS是承接圣母圣咏和Alicezation呢？但是这么说来，并没有什么问题…因为Alicezation篇只有一两个月。</li>
<li><del>川原吃设定系列</del></li>
</ul>
<p><img src="https://s1.ax1x.com/2018/08/02/P0V1eK.png" alt="P0V1eK.png"></p>
<hr>
<p><img src="https://s1.ax1x.com/2018/08/02/P0ZZ0f.png" alt="P0ZZ0f.png"></p>
<ul>
<li>这一段是个人感觉最好笑的一段</li>
<li>我们以后就叫桐人老爷“中毒网友废人”算了</li>
<li>下面这两大段讲的就是9-18章的大致内容…汉化组是真的皮</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/08/02/P0ZNAU.png" alt="P0ZNAU.png"></p>
<ul>
<li>菊冈诚二郎【简称菊冈】就是坑桐人老爷的人，GGO事件就是他委托桐人老爷去办的，<br>送桐人去实验STL也是他弄得，不过…没有他，桐人就不会掺和死枪事件，也不会被注射琥珀胆碱，<br>更不会进入UnderWorld…但也不会认识诗乃和爱丽丝。那么在OS事件中…桐人… 不想了</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/08/02/P0KCQJ.png" alt="P0KCQJ.png"></p>
<ul>
<li>这是继西莉卡、诗乃后第三个选择猫妖的女主角…就亚丝娜…算了</li>
<li>这里为桐人老爷接下来的修罗场做铺垫</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/08/02/P01DvF.png" alt="P01DvF.png"></p>
<ul>
<li>其实爱丽丝真的是一个命运复杂的人，被最高祭司夺了记忆拿不回来不说，就连来到RealWorld还要被人做实验</li>
<li>PS：在失忆前，爱丽丝喜欢优吉欧，失忆以后喜欢桐人</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/08/02/P01L5t.png" alt="P01L5t.png"></p>
<ul>
<li>从这里可以看出，爱丽丝不太适应RealWorld的生活，所以才想回到UnderWorld</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/08/02/P0cAFP.png" alt="P0cAFP.png"></p>
<ul>
<li>神代凛子博士就是茅场的妻子，但她和SAO事件并没有太大关系</li>
<li>这里“现在的人界政府”指的就是UnderWorld中的人界政府</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/08/02/P0ctlF.png" alt="P0ctlF.png"></p>
<ul>
<li>这里重新提一下猫妖<blockquote>
<p>猫妖擅长驯化魔兽、敏捷、视力高</p>
</blockquote>
</li>
<li>所以，诗乃作为狙击手（暂且这么叫吧），西莉卡和爱丽丝为了驯化都选了猫妖。</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/08/02/P0cg6e.png" alt="P0cg6e.png"></p>
<ul>
<li>从这里，就到了我最感兴趣的情节了-桐人老爷的修罗场</li>
<li>当SAO篇和Alicezation篇的女主角碰到一起，会发生什么呢？？？</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/08/02/P0cItP.png" alt="P0cItP.png"></p>
<ul>
<li>桐人老爷可真是幸福呢，左拥右抱可还行，不过这里也是可以看出桐人老爷的冷静【表面慌得一批，实则比老狗还稳.jpg】</li>
</ul>
<p><img src="https://s1.ax1x.com/2018/08/02/P0cqXQ.png" alt="P0cqXQ.png"></p>
<ul>
<li>注意这段文字：<blockquote>
<p>被染成红色的不是天空，而是以猛烈的势头布满天空的镶嵌六边形【Hexagon Pattern】。<br>而交替出现在六边形表面的，则是〖Warning〗和〖System Announcement〗这样的文字。</p>
</blockquote>
</li>
<li>这一天，SAO的玩家们终于想起了四年前被那个[阴魂不散的男人]所支配的恐惧…</li>
<li>但是，这并不代表着这一定是那个男人引起的，因为后面也没有了</li>
</ul>
<h1 id="EP4-后记"><a href="#EP4-后记" class="headerlink" title="EP4 - 后记"></a>EP4 - 后记</h1><p>对！没有了。不过从先导来看，应该挺有趣的…不过把Augma搬进来也是够了，<br>川原的脑洞被挖空了…</p>
<p>不过，按道理来说，应该九、十月份21册就出了…敬请期待吧…</p>
<h1 id="EP5-鸣谢"><a href="#EP5-鸣谢" class="headerlink" title="EP5 - 鸣谢"></a>EP5 - 鸣谢</h1><blockquote>
<ul>
<li><a href="https://tieba.baidu.com/f?kw=%E5%88%80%E5%89%91%E7%A5%9E%E5%9F%9F&amp;ie=utf-8">百度贴吧-刀剑神域吧</a></li>
<li><a href="http://alfheim.cc">Alfheim.cc</a></li>
<li><a href="https://water_mi.coding.me/Blog-Hexo">water_mi’s Blog</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>[随便写写]吐槽</tag>
      </tags>
  </entry>
</search>
